<title>Road</title>
<link rel="stylesheet" href="../grid.css">

<canvas id="canvas" width="1000px" height="1000px"></canvas>

<script type="module">

  import { Curve } from './Curve.js';
  import { Line } from './Line.js';
  import * as CellGrid from './CellGrid.js';

  const canvas = document.getElementById( 'canvas' );
  const ctx = canvas.getContext( '2d' );



  const COLS = 5, ROWS = 5, SIZE = 200;

  const cells = CellGrid.getSquareGrid( COLS, ROWS, SIZE, 0 );

  const start = cells[ 0 ];

  CellGrid.linkMaze( start );

  cells.forEach( cell => {
    cell.draw( ctx );

    const width = SIZE * ( 0.1 + 0.2 * Math.random() );

    cell.caveNode = {
      x: cell.x + ( SIZE - 2 * width ) * ( 0.5 - Math.random() ),
      y: cell.y + ( SIZE - 2 * width ) * ( 0.5 - Math.random() ),
      width: width,
    };

    ctx.beginPath();
    ctx.arc( cell.caveNode.x, cell.caveNode.y, cell.caveNode.width, 0, Math.PI * 2 );
    ctx.fill();
  } );


  const lines = getLines( start );

  for ( let i = 0; i < lines.length; i ++ ) {
    const curr = lines[ i ];
    const next = lines[ ( i + 1 ) % lines.length ];
    
    const intersection = Line.getIntersection(
      curr.x1, curr.y1, curr.x2, curr.y2,
      next.x1, next.y1, next.x2, next.y2,
    );

    if ( 0 <= intersection && intersection <= 1 ) {
      const hitX = curr.x1 + ( curr.x2 - curr.x1 ) * intersection;
      const hitY = curr.y1 + ( curr.y2 - curr.y1 ) * intersection;

      curr.x2 = next.x1 = hitX;
      curr.y2 = next.y1 = hitY;
    }
  }

  ctx.lineWidth = 2;
  ctx.strokeStyle = 'yellow';

  ctx.beginPath();
  lines.forEach( line => {
    ctx.lineTo( line.x1, line.y1 );
    ctx.lineTo( line.x2, line.y2 );
  } );
  ctx.stroke();

  function getLines( startNode ) {
    const lines = [];

    const visited = new Set();
    let cell = startNode;
    let index = 0;
    let edge = cell.edges[ index ];

    while( !visited.has( edge ) ) {
      visited.add( edge );

      if ( edge.linked ) {
        lines.push( getLine( edge ) );

        edge = edge.neighbor;
        cell = edge.parent;
        index = cell.edges.findIndex( e => e == edge );
      }

      index = ( index + 1 ) % cell.edges.length;
      edge = cell.edges[ index ];
    }

    return lines;
  }

  function getLine( edge ) {
    const from = edge.parent.caveNode; 
    const to = edge.neighbor.parent.caveNode;

    const normal = Math.atan2( to.x - from.x, from.y - to.y );

    return new Line(
      from.x + Math.cos( normal ) * from.width,
      from.y + Math.sin( normal ) * from.width,
      to.x   + Math.cos( normal ) * to.width,
      to.y   + Math.sin( normal ) * to.width
    );
  }


  // const curves = Curve.getCurvesThroughPoints( [
  //   [ 0, 0 ], [ 0, 1 ], [ 1, 1 ], [ 2, 1 ], [ 2, 0 ], [ 3, 0 ], 
  //   [ 3, 1 ], [ 3, 2 ], [ 3, 3 ], [ 2, 3 ], [ 2, 2 ], [ 1, 2 ], [ 1, 3 ],
  // ].map( e => 
  //   e.map( i => SIZE * ( i + 0.25 + 0.5 * Math.random() ) ) 
  // ) );

  // const widths = Array.from( Array( curves.length + 1 ), _ => 20 + 30 * Math.random() );

  // const left = [], right = [];

  // curves.forEach( ( curve, i ) => {   
  //   const startWidth = widths[ i ], endWidth = widths[ i + 1 ];
  //   for ( let t = 0; t <= 1; t += 0.1 ) {
  //     const pos = curve.getPosition( t );
  //     const norm = curve.getNormal( t );
      
  //     const width = startWidth + ( endWidth - startWidth ) * t;
      
  //     left.push( {
  //       x: pos[ 0 ] - norm[ 0 ] * width,
  //       y: pos[ 1 ] - norm[ 1 ] * width,
  //     } );
      
  //     right.unshift( {
  //       x: pos[ 0 ] + norm[ 0 ] * width,
  //       y: pos[ 1 ] + norm[ 1 ] * width,
  //     } );
  //   }
  // } );

  // const path = new Path2D();

  // left.forEach( p => path.lineTo( p.x, p.y ) );
  // right.forEach( p => path.lineTo( p.x, p.y ) );

  // path.closePath();

  // ctx.fillStyle = 'green';
  // ctx.fill( path );

</script>