NOW:
  - Make olympic rings-style connection of circles
  - Run circles CW and CCW, have different numbers of lanes
  - Make it a nice comprehensive test of intersections

NEXT:
  - Try to navigate paths with nexts that account for distance (instead of all being at end)
  - This is a little weird, but could avoid lots of awkward splitting
    - See if it's easiser to work with!


- Intersections of non-perpendicular lines
  - Can we still get nice arcs for these? Or will they be all screwed up?
  - Don't trim intersections as much if they aren't right angle
    - Make dependent on angle somehow

- 4-way stop
  - Simulate by quickly rotating short windows for each direction and specify yield?
    - Yield should keep them from crashing
    - Quickly rotating windows should prevent the same lane from going multiple times if someone else is waiting

- Intersections involving arcs
  - Arc vs Line
  - Arc vs Arc


Automatic intersections between arbitrary lines is hard. 
What if I did more like a train set, predefined acceptable intersections and pieces and linked them together?

- Splitting and merging lanes
  - e.g. splitting to add a left turn lane
  - Change streets to have lane info as part of start and end:
    street: {
      start: {
        pos: [ x, y ],
        lanes: {
          left: 1,
          right: 2,
        },
      },
      end: {
        pos: [ x, y ],
        lanes: {
          left: 2,
          right: 2,
        },
      },
    }
  - Longer, but I think it's the clearest way to save this info

Someday might want to just do lots of short lines (e.g. from bezier curve), but I like the simplicity of lines and arcs for now


Instead of spliting routes up, what if we had "next" include distance at which it branches off?
e.g.
  route: {
    start: [ 0,  0 ],
    end:   [ 0, 10 ],
    next: [
      { name: 'moo', distance: 5 },
      { name: 'quack', distance: 7 },
    ],
  }

Then I could have fewer routes for intersections and lane changes.
  - Instead of checking for next route once I've reached end of current route,
    see when we've passed next route's distance. (I think I already know next route anyway nowadays)
  - Does this make pathfinding weirder?

Counter to this: for enforcing paths on intersections, we want a clear point at which intersection begins/ends
  - We'll probably want this for drawing, too
  - We could save this information as bounds for the intersection object, doesn't necessarily need to be baked into splits
