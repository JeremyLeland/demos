2/4:

Now focus on making editor more usable, see what I can do with the road linking I have
  - Clicking and dragging should create new road instead of editing existing one
  - Clicking without dragging should select a road (with clear indicator of selection)
  - Clicking and dragging a selected road will edit it (middle clicking should move it!)
  - Scrolling on a selected road to increase/decrease lanes?

As a bonus, check for intersections against self by looking for sweepAngle close to 2*PI
  - If so, join against ourselves...see if this can be done easily
    - I keep trying to make circles while testing

U-turns are causing so many headaches...what if I just disabled them for now?
  - Big part of why I had them initially was so we could draw outline without hard edges
  - I gave up on that and added hard edge support
  - Maybe it would be less squirrely without u-turns?

I want to try being more deliberate about how I edit
  - I want to use branches focused on a specific change
  - Make that change, then merge the branch
    - Not sure I've ever actually done that successfully
  - Part of this could include making bugs again for tasks, but that got kind of overwhelming
    - I mostly didn't finish tasks, so they just stacked up

I like the idea of writing things down in here.
  - I can always come back and look for them, if I really need to
  - But mostly the important stuff should keep getting persisted
  - If little things get forgotten and I never think of them again, they probably weren't important

2/3:

Went down rabbit hole of trying to remove dangling joins, but there are situations where it is hard to know what should be removed. I think it's going to be better to leave the weird joins in and just draw a valid outline.

I started down this road yesterday with "failedLinks" that could be searched for while determining the outline path. I need similar information to links -- know when to exit the current route, what the next route is, and where to join it. I think that's enough...

Yesterday I had the wrong intersection (street intersection vs route intersection). I'll need to test when routes intersect twice and make sure I'm using the one closest to street intersection. Maybe I should build this into library code somewhere...

Ok, first piece working. Simply returning the next failedLink if it's closer than working link kind of works
  - The drawing code advances to the path we failed to link to, which is what I thought I wanted
  - Issues:
    - It goes until the offset of the from route, then backtracks to the offset of the other. I need it to stop where these offsets intersect. 
      + Maybe I can calculate this and save as part of failedLink? Then we can check for it and draw a bit differently
    - It doesn't make sure the failed route has anywhere to go.
      + We should ignore it in these cases. 
      + Something else to check as part of failed link?

Addressed failedLinks going nowhere, sort of.

There's a tension here between the creation of links and the creation of u-turns. We currently wait before all the links are made before determining whether there should be a u-turn. But we want to know if there's a u-turn before we make a failedLink.

Either at creation or later, we need to check for whether a road goes somewhere before we draw a failedLink.
  + Maybe we can call a separate check that only looks for valid links, instead of re-calling the function with failedLinks?
  - Not sure how common the failedLink to failedLink needing to be drawn is...
  - If it's something we really need, then maybe we can agree to only check 2 or 3 levels deep

2/2:

Even when checking street length, I still get in the situation where arcs fit in one direction but are too big to fit in the other direction

I could prevent this by requiring longer roads (and seemed to with minimum length of 2), but I don't know how long is enough minimum.

It would be nice if I could just try to put arcs in every direction, and rescind the ones that aren't long enough. This gets me back to the problem of not knowing *why* a given arc failed. Is it because the startAngle was too long or the endAngle?
  - Is there a way to return this information from the arc generating function?
  - Can I look at which ones were successful?
    - If all 4 worked, we're good
    - If only 3 worked, it'll need to be a 3-way intersection. Focus on the street that has two working, and discard the rest
    - If only 2 worked...not sure. I'm having trouble creating a situation where only two work that isn't just a valid 3 way
    - So maybe just try to resolve the 3-worked case?

Can I make getBestJoinRadius tell me if it'll work? Since I'm testing what fits there anyway. Maybe give that a minimum and have it fail if nothing fits?

Seems like I should do this in two passes:
  1) Find the best radius for each quadrant
  1.5) Remove dangling quandrant
  2) Actually add pairs for appropriate quadrants

So would this be splitting up addPairs?

ALTERNATIVE:
  - Support hard intersections like this for drawing purposes
  - Nothing is necessarily wrong with the routes. This is navigatable. They just can't turn left.
  - The user will probably see this isn't what they want and change it. But we should be more robust in drawing it.
    - Could save a lot of effort trying to figure out which arcs are valid and which aren't
  - This is kind of like an intersection with a one-way road (we'll have the same problem there, right?)

We'd need to check for an intersection between streets, or maybe routes?
  - Everything with drawing a street deals with the outside routes, so just check those

Maybe have "nonlinks" (or better name) where I add routes that we were unable to connect with?
  - This could be used for drawing hard boundaries
  - Not sure if it ends up being useful for anything else, maybe something with intersections

NOW: Trying to create "failedLinks" that I can use for drawing
  - These are pretty close to normal links in terms of what they store
  - Trying to generate them in joinRoutes for now
    - Having some issues with getting proper intersection, need to make sure it's closest!

Actually, I don't like this alternative. I haven't implemented it to the point of working, but it feels like it would be cleaner to just not allow the dangling joins. I want to try splitting up the join work to find the radii and then remove the dangling join.

Trying to implement removal of dangling join. I'm worried this will be relative to my example and break if I move the lines around, though...also, it doesn't have enough info to resolve 2 opposing danglers. Might still want some sense of which streets are shortest to know what to exclude.

Never mind, this is dumb. There isn't enough information to know what to throw away in the dangling 3 case sometimes, either.
Probably best to just draw everything with the hard edge at let user adjust, since it's a monstrosity anyway.
