<title>Hex Grid, highlight under mouse</title>
<link rel="stylesheet" href="../grid.css">

<script type="module">
  import { Canvas } from './Canvas.js';
  import * as Tantrix from './Tantrix.js';

  const SIZE = 16;

  const canvas = new Canvas();

  let mouseX = 0, mouseY = 0;

  canvas.draw = ( ctx ) => {
    // ctx.translate( 0.5, 0.5 );
    ctx.scale( 1 / SIZE, 1 / SIZE );
    
    for ( let row = 0; row < 14; row ++ ) {
      for ( let col = 0; col < 14; col ++ ) {
        const x = Tantrix.gridX( col, row );
        const y = Tantrix.gridY( col, row );
  
        ctx.translate( x, y );
        ctx.strokeStyle = 'black';
        ctx.lineWidth = 1 / SIZE;
        ctx.stroke( Tantrix.HexagonPath );

        ctx.font = '0.4px Arial';
        ctx.textAlign = 'center';
        ctx.shadowColor = 'black';
        ctx.shadowOffsetX = 2;
        ctx.shadowOffsetY = 2;

        ctx.fillStyle = 'white';
        ctx.fillText( `(${ col }, ${ row })`, 0, 0 );

        ctx.translate( -x, -y );
      }
    }

    const HALF_WIDTH = 0.5;
    const HALF_HEIGHT = 0.5 * Math.sqrt( 3 );

    const halfCol = Math.floor( mouseX / HALF_WIDTH );
    const halfRow = Math.floor( mouseY / HALF_HEIGHT );

    console.log( `mouseX = ${ mouseX }, halfCol = ${ halfCol } )` );
    console.log( `mouseY = ${ mouseY }, halfRow = ${ halfRow } )` );

    let mouseCol, mouseRow;

    mouseCol = Math.floor( ( halfCol + 1 ) / 3 );
    mouseRow = Math.floor( mouseY / Math.sqrt( 3 ) + ( Math.abs( mouseCol + 1 ) % 2 ) / 2 );

    if ( ( halfCol - 1 ) % 3 == 0 ) {
      let x1, y1, w, h;

      if ( halfRow % 2 == halfCol % 2 ) {
        x1 = HALF_WIDTH * halfCol;
        y1 = HALF_HEIGHT * halfRow;
        w = HALF_WIDTH;
        h = HALF_HEIGHT;
      }
      else {
        x1 = HALF_WIDTH * ( halfCol + 1 );
        y1 = HALF_HEIGHT * halfRow;
        w = -HALF_WIDTH;
        h = HALF_HEIGHT;
      }

      // ( x - x1 ) * ( y1 - y2 ) + ( y - y1 ) * ( x2 - x1 ) < 0;
      const dist = ( mouseX - x1 ) * -h + ( mouseY - y1 ) * w;

      console.log( `dist = ${ dist }` );

      if ( dist < 0 ) {
        ctx.fillStyle = '#f00a';
        mouseCol ++;

        if ( halfCol % 2 == 1 ) {
          mouseRow -= halfRow % 2;
        }
        else {
          mouseRow += halfRow % 2;
        }
      }
      else { 
        ctx.fillStyle = '#fa0a';
        
      }

      ctx.strokeStyle = 'yellow';
      ctx.beginPath();
      ctx.moveTo( x1, y1 );
      ctx.lineTo( x1 + w, y1 + h );
      ctx.stroke();
    }
    else {
      ctx.fillStyle = '#00fa';

      
    }

    ctx.fillRect( HALF_WIDTH * halfCol, 0, HALF_WIDTH, 10 );

    
    

    const x = Tantrix.gridX( mouseCol, mouseRow );
    const y = Tantrix.gridY( mouseCol, mouseRow );

    ctx.translate( x, y );
    ctx.strokeStyle = 'white';
    ctx.lineWidth = 1 / SIZE;
    ctx.stroke( Tantrix.HexagonPath );

    ctx.translate( -x, -y );
  }

  function pointInsideLine( x, y, x1, y1, x2, y2 ) {
    return ( x - x1 ) * ( y1 - y2 ) + ( y - y1 ) * ( x2 - x1 ) < 0;
  }

  canvas.redraw();

  document.addEventListener( 'pointermove', e => {
    mouseX = SIZE * e.clientX / canvas.scale;
    mouseY = SIZE * e.clientY / canvas.scale;
    canvas.redraw();
  } );

</script>
