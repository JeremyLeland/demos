<link rel="stylesheet" href="../grid.css">

<script type="module">
  import * as THREE from '../lib/three.module.js';
  import * as MeshDemo from './meshDemo.js';

  const uniforms = {
  };

  // Trying to shade and fill a parabola based on point's distance from curve
  // Eventually, find arc length between start and end and set curve width
  // based on start and end width?

  MeshDemo.meshDemo( new THREE.Mesh(
    new THREE.PlaneGeometry( 5, 5 ),
    new THREE.ShaderMaterial( {
      uniforms: uniforms,
      vertexShader: /* glsl */ `
        out vec3 v_pos;
        out vec3 v_normal;

        void main() {
          v_pos = position;
          v_normal = normal;
          
          gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
        }
      `,
      fragmentShader: /* glsl */ `
        #define PI 3.14159265359

        in vec3 v_pos;
        in vec3 v_normal;

        out vec3 outColor;

        // https://www.geogebra.org/m/JA9vHxWT
        // d' = ( x^2 - b ) * 2x + ( x - a )
        // d' = 2x^3 + 0x^2 + ( 1 - 2b )x - a
        // a = 2, b = 0, c = ( 1 - 2b ), d = -a

        float cubeRoot( float val ) {
          float fixNeg = val < 0.0 ? -1.0 : 1.0;
          return fixNeg * pow( fixNeg * val, 1.0 / 3.0 );
        }

        void main() {

          float a = 2.0, b = 0.0, c = ( 1.0 - 2.0 * v_pos.y ), d = -v_pos.x;

          // https://github.com/BaseMax/CubicEquationCalculator
          b /= a;
          c /= a;
          d /= a;

          float q = (
              3.0 * c - (b * b)
          ) / 9.0;
          float r = (
              -(27.0 * d) + b * (
                  9.0 * c - 2.0 * (b * b)
              )
          ) / 54.0;

          float discrim = q * q * q + r * r;

          float term1 = b / 3.0;


          float root = 0.0;
          float dist = 0.0;

          // One real root, two complex
          if ( discrim > 0.0 ) {
            float s = cubeRoot( r + sqrt( discrim ) );
            float t = cubeRoot( r - sqrt( discrim ) );

            root = -term1 + s + t;
            // ignore complex roots

            dist = sqrt( pow( root * root - v_pos.y, 2.0 ) + pow( root - v_pos.x, 2.0 ) );
          }

          // All roots real, at least two are equal
          else if ( discrim == 0.0 ) {
            float r13 = cubeRoot( r );

            root = -term1 + 2.0 * r13;
            // ignore complex roots

            dist = sqrt( pow( root * root - v_pos.y, 2.0 ) + pow( root - v_pos.x, 2.0 ) );
          }

          // All roots are real and unequal
          else {
            float dum1 = acos(r / sqrt(-q * -q * -q));
            float temp = -term1 + 2.0 * sqrt(-q);

            float root1 = temp * cos( dum1 / 3.0 );
            float root2 = temp * cos( ( dum1 + 2.0 * PI ) / 3.0 );
            float root3 = temp * cos( ( dum1 + 4.0 * PI ) / 3.0 );

            float dist1 = sqrt( pow( root1 * root1 - v_pos.y, 2.0 ) + pow( root1 - v_pos.x, 2.0 ) );
            float dist2 = sqrt( pow( root2 * root2 - v_pos.y, 2.0 ) + pow( root2 - v_pos.x, 2.0 ) );
            float dist3 = sqrt( pow( root3 * root3 - v_pos.y, 2.0 ) + pow( root3 - v_pos.x, 2.0 ) );

            dist = min( dist1, min( dist2, dist3 ) );
          }

          outColor = vec3( 1.0 - dist, 0.0, 0.0 );
        }
      `,
      glslVersion: THREE.GLSL3,
    } )
  ) );

</script>
