<title>Drag control points to make levels</title>
<link rel="stylesheet" href="../grid.css">

<script type="module">
  import { Canvas } from './Canvas.js';
  import { Line } from './Line.js';

  const EditType = {
    AddPoint: 'AddPoint',
    MovePoint: 'MovePoint',
    DeletePoint: 'DeletePoint',
    AddLoop: 'AddLoop',
    MoveLoop: 'MoveLoop',
    ResizeLoop: 'ResizeLoop',
    DeleteLoop: 'DeleteLoop',
  };

  const ResizeType = {
    NW: 0, N: 1, NE: 2,
     W: 7,       E:  3,
    SW: 6, S: 5, SE: 4,
  };

  const loops = [
    getLoop( 3, -5, 10, -3 ),
    getLoop( -7, -2, -1, 2 ),
    getLoop( 2, 1, 11, 3 ),
    getLoop( -1, 5, 8, 9 ),
  ];

  // console.log( JSON.stringify( loops ) );
  
  

  // const lines = [];
  // loops.forEach( loop => {
  //   for ( let i = 0; i < loop.length; i ++ ) {
  //     lines.push( new Line( ...loop[ i ], ...loop[ ( i + 1 ) % loop.length ] ) );
  //   }
  // } );

  const SIZE = 16;

  const canvas = new Canvas();
  canvas.zoom = 1 / SIZE;
  canvas.scrollX = SIZE / 2;
  canvas.scrollY = SIZE / 2;
  canvas.redraw();

  const POINT_RADIUS = 0.06;

  let selected, hover;
  let active;

  canvas.draw = ( ctx ) => {
    // Loops
    ctx.fillStyle = 'green';
    loops.forEach( loop => {
      ctx.beginPath();
      loop.forEach( p => ctx.lineTo( p[ 0 ], p[ 1 ] ) );
      ctx.fill();
    } );

    // Bounds
    if ( selected ) {
      const boundsInfo = getBoundsInfo( selected.bounds );
      
      ctx.fillStyle = ctx.strokeStyle = '#fffa';

      ctx.setLineDash( [ 0.1, 0.1 ] );
      ctx.beginPath();
      boundsInfo.edges.forEach( e => {
        ctx.moveTo( e[ 0 ], e[ 1 ] );
        ctx.lineTo( e[ 2 ], e[ 3 ] );
      } );
      ctx.stroke();
      ctx.setLineDash( [] );

      ctx.beginPath();
      boundsInfo.points.forEach( p => {
        drawPoint( ctx, p, POINT_RADIUS );
      } );
      ctx.fill();
    }

    // Points
    ctx.fillStyle = '#fffa';
    ctx.beginPath();
    loops.forEach( loop => {
      loop.forEach( p => {
        drawPoint( ctx, p, POINT_RADIUS );
      } );
    } );
    ctx.fill();

    if ( hover ) {
      ctx.fillStyle = hover.type == EditType.MovePoint ? 'yellow' : 'lime';

      ctx.beginPath();

      if ( hover.point ) {
        drawPoint( ctx, hover.point, POINT_RADIUS * 2 );
      }
      else if ( hover.pointIndex != null ) {
        drawPoint( ctx, loops[ hover.loopIndex ][ hover.pointIndex ], POINT_RADIUS * 2 );
      }
      
      ctx.fill();  
    }

    // ctx.strokeStyle = 'white';
    // lines.forEach( line => line.draw( ctx ) );
  }

  function getBoundsInfo( bounds ) {
    const points = [
      [ bounds.left,  bounds.top    ],
      [ bounds.right, bounds.top    ],
      [ bounds.right, bounds.bottom ],
      [ bounds.left,  bounds.bottom ],
    ];

    const edges = [
      [ ...points[ 0 ], ...points[ 1 ] ],
      [ ...points[ 1 ], ...points[ 2 ] ],
      [ ...points[ 2 ], ...points[ 3 ] ],
      [ ...points[ 3 ], ...points[ 0 ] ],
    ];

    return {
      points: points,
      edges: edges,
    };
  }
  
  function drawPoint( ctx, p, radius ) {
    ctx.moveTo( p[ 0 ], p[ 1 ] );
    ctx.arc( p[ 0 ], p[ 1 ], radius, 0, Math.PI * 2 );
  }


  // TODO: Click and drag a rectangle to make a new loop (when not in rectangle)
  // TODO: Move and resize existing loops
  //         - Hovering over loop shows move box and resize corners? (probably more intuitive)
  //         - Or just right-click drag inside loop to resize it?
  // TODO: Remove point
  // TODO: Add point (show new point when hover close to line, create when click)
  // TODO: Undo/Redo (requires serializing operations: move, resize, delete, etc)
  //         - Or just save the whole level state...might be easier than trying to add back points

  let mouse = {
    x: 0,
    y: 0,
  }

  document.addEventListener( 'pointerdown', e => {
    mouse.x = canvas.getPointerX( e );
    mouse.y = canvas.getPointerY( e );

    active = getEditUnder( mouse.x, mouse.y );
    hover = null;

    // TODO: Move to getEditUnder?
    if ( !active ) {
      selected = null;

      for ( let i = 0; i < loops.length; i ++ ) {
        const bounds = {};

        // TODO: Bounds calc in the getBoundsInfo, don't try to cache it?
        loops[ i ].forEach( p => {
          bounds.left   = Math.min( p[ 0 ], bounds.left   ?? p[ 0 ] );
          bounds.right  = Math.max( p[ 0 ], bounds.right  ?? p[ 0 ] );
          bounds.top    = Math.min( p[ 1 ], bounds.top    ?? p[ 1 ] );
          bounds.bottom = Math.max( p[ 1 ], bounds.bottom ?? p[ 1 ] );
        } );

        if ( bounds.left <= mouse.x && mouse.x <= bounds.right && 
             bounds.top  <= mouse.y && mouse.y <= bounds.bottom ) {
          if ( e.buttons & 1 ) {
            selected = {
              loopIndex: i,
              bounds: bounds,
            };
            
            active = {
              type: EditType.MoveLoop,
              loopIndex: i,
              dx: 0,
              dy: 0,
            };
          }
          else if ( e.buttons & 2 ) {
            active = {
              type: EditType.DeleteLoop,
              loopIndex: i,
            };

            console.log( active );

            loops.splice( active.loopIndex, 1 );

            active = null;
          }
            
          break;
        }
      }

      if ( !active && e.buttons & 1 ) {
        active = {
          type: EditType.AddLoop,
          loopIndex: loops.length,
          dragStart: [ mouse.x, mouse.y ],
        }
      }
    }
    else if ( active.type == EditType.AddPoint ) {
      if ( e.buttons & 1 ) {
        console.log( active );
        
        loops[ active.loopIndex ].splice( active.pointIndex, 0, active.point );
        
        active = {
          type: EditType.MovePoint,
          loopIndex: active.loopIndex,
          pointIndex: active.pointIndex,
          dx: 0,
          dy: 0,
        }
      }
      else {
        active = null;
      }
    }
    else if ( active.type == EditType.MovePoint ) {
      if ( e.buttons & 2 ) {
        active = {
          type: EditType.DeletePoint,
          loopIndex: active.loopIndex,
          pointIndex: active.pointIndex,
        }

        console.log( active );

        loops[ active.loopIndex ].splice( active.pointIndex, 1 );

        active = null;
      }
    }

    canvas.redraw();
  } );

  document.addEventListener( 'pointermove', e => {
    const lastX = mouse.x;
    const lastY = mouse.y;
    mouse.x = canvas.getPointerX( e );
    mouse.y = canvas.getPointerY( e );
    const moveX = mouse.x - lastX;
    const moveY = mouse.y - lastY;

    // Move active points (or resize)
    if ( active ) {
      if ( active.type == EditType.MovePoint ) {
        const p = loops[ active.loopIndex ][ active.pointIndex ];
        p[ 0 ] += moveX;
        p[ 1 ] += moveY;

        active.dx += moveX;
        active.dy += moveY;
      }
      else if ( active.type == EditType.MoveLoop ) {
        loops[ active.loopIndex ].forEach( p => {
          p[ 0 ] += moveX;
          p[ 1 ] += moveY;
        } );

        active.dx += moveX;
        active.dy += moveY;

        selected.bounds.left   += moveX;
        selected.bounds.right  += moveX;
        selected.bounds.top    += moveY;
        selected.bounds.bottom += moveY;
      }
      else if ( active.type == EditType.ResizeLoop ) {
        const oldBounds = Object.assign( {}, selected.bounds );

        if ( active.resizeType == ResizeType.NW ) {
          selected.bounds.left += moveX;
          selected.bounds.top  += moveY;
        }
        else if ( active.resizeType == ResizeType.NE ) {
          selected.bounds.right += moveX;
          selected.bounds.top   += moveY;
        }
        else if ( active.resizeType == ResizeType.SE ) {
          selected.bounds.right  += moveX;
          selected.bounds.bottom += moveY;
        }
        else if ( active.resizeType == ResizeType.SW ) {
          selected.bounds.left   += moveX;
          selected.bounds.bottom += moveY;
        }

        loops[ active.loopIndex ].forEach( p => {
          const u = ( p[ 0 ] - oldBounds.left ) / ( oldBounds.right - oldBounds.left );
          const v = ( p[ 1 ] - oldBounds.top ) / ( oldBounds.bottom - oldBounds.top );
          
          p[ 0 ] = selected.bounds.left + u * ( selected.bounds.right - selected.bounds.left );
          p[ 1 ] = selected.bounds.top  + v * ( selected.bounds.bottom - selected.bounds.top );
        } );

        active.dx += moveX;
        active.dy += moveY;
      }
    }

    // Hover
    else {
      hover = getEditUnder( mouse.x, mouse.y );
    }

    canvas.redraw();
  } );

  document.addEventListener( 'pointerup', e => {
    if ( active ) {

      if ( active.type == EditType.AddLoop ) {
        const left   = Math.min( active.dragStart[ 0 ], mouse.x );
        const right  = Math.max( active.dragStart[ 0 ], mouse.x );
        const top    = Math.min( active.dragStart[ 1 ], mouse.y );
        const bottom = Math.max( active.dragStart[ 1 ], mouse.y );

        if ( left != right && top != bottom ) { 
          active.points = getLoop( left, top, right, bottom );
          loops.splice( active.loopIndex, 0, active.points );
        }
        else {
          active = null;
        }
      }

      if ( active ) {
        console.log( active ); 
        active = null;
      }
    }

    canvas.redraw();
  } );

  function getLoop( left, top, right, bottom ) {
    const loop = [];

    const width = ( right - left ) / 2;
    const height = ( bottom - top ) / 2;
    const x = left + width;
    const y = top + height;

    const numPoints = 10 + width * height;
    for ( let i = 0; i < numPoints; i ++ ) {
      const angle = Math.PI * 2 * ( i + 0.5 * Math.random() ) / numPoints;
      const dist = 0.8 + 0.2 * Math.random();
      loop.push( [ 
        x + width  * dist * Math.cos( angle ), 
        y + height * dist * Math.sin( angle ),
      ] );
    }

    return loop;
  }

  function getEditUnder( targetX, targetY ) {
    // Resize selected
    if ( selected ) {
      const boundsInfo = getBoundsInfo( selected.bounds );

      let closestPoint, closestIndex, closestDist = Infinity;
      boundsInfo.points.forEach( ( p, index ) => {
        const dist = Math.hypot( p[ 0 ] - targetX, p[ 1 ] - targetY );

        if ( dist < closestDist ) {
          closestPoint = p;
          closestIndex = index;
          closestDist = dist;
        }
      } );

      if ( closestDist < POINT_RADIUS * 4 ) {
        return  {
          type: EditType.ResizeLoop,
          resizeType: closestIndex * 2,  // resizeTypes alternate between point and edge
          loopIndex: selected.loopIndex,
          dx: 0,
          dy: 0,
        };
      }
    }

    // Move point
    {
      let closestLoopIndex, closestPointIndex, closestDist = Infinity;
      loops.forEach( ( loop, loopIndex ) => {
        loop.forEach( ( p, pointIndex ) => {
          const dist = Math.hypot( p[ 0 ] - targetX, p[ 1 ] - targetY );

          if ( dist < closestDist ) {
            closestLoopIndex = loopIndex;
            closestPointIndex = pointIndex;
            closestDist = dist;
          }
        } );
      } );

      if ( closestDist < POINT_RADIUS * 4 ) {
        return {
          type: EditType.MovePoint,
          loopIndex: closestLoopIndex,
          pointIndex: closestPointIndex,
          dx: 0,
          dy: 0,
        };
      }
    }

    // Add point
    {
      let closestPoint, closestLoopIndex, closestPointIndex, closestDist = Infinity;
      loops.forEach( ( loop, loopIndex ) => {
        for ( let i = 0; i < loop.length; i ++ ) {
          const current = loop[ i ];
          const next = loop[ ( i + 1 ) % loop.length ];

          const x1 = current[ 0 ];
          const y1 = current[ 1 ];
          const x2 = next[ 0 ];
          const y2 = next[ 1 ];

          const px = x2 - x1;
          const py = y2 - y1;
          const D = ( px * px ) + ( py * py );

          const len = Math.sqrt( D );
          const normX = py / len;
          const normY = -px / len;
          
          const u = ( ( targetX - x1 ) * px + ( targetY - y1 ) * py ) / D;

          if ( 0 <= u && u <= 1 ) {
            const x = x1 + u * px;
            const y = y1 + u * py;

            const dist = Math.abs( ( targetX - x1 ) * normX + ( targetY - y1 ) * normY );

            if ( dist < closestDist ) {
              closestLoopIndex = loopIndex;
              closestPointIndex = i + 1;    // will add after current point
              closestPoint = [ x, y ];
              closestDist = dist;
            }
          }
        }
      } );

      if ( closestDist < POINT_RADIUS * 4 ) {
        return {
          type: EditType.AddPoint,
          loopIndex: closestLoopIndex,
          pointIndex: closestPointIndex,
          point: closestPoint,
        };
      }
    }
  }

</script>