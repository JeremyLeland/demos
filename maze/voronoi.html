<title>Voronoi</title>
<link rel="stylesheet" href="../style.css">

<body>
  <canvas id="canvas" width="800px" height="800px"></canvas>
</body>

<script type="module">

  import { Cell } from '../src/Cell.js';
  import * as Voronoi from '../src/Voronoi.js';

  
  const width = 800, height = 800;
  const MIN_EDGE_LENGTH = 40;

  const seeds = Array.from( Array( 40 ), _ => ( {
    x: Math.random() * width, 
    y: Math.random() * height
  } ) );

  let cells = Voronoi.getVoronoiCells( seeds );

  cells.forEach( cell => {
    cell.edges.forEach( edge => {
      // Detach edges that are too small to fit through
      if ( Math.hypot( edge.end.x - edge.start.x, edge.end.y - edge.start.y ) < MIN_EDGE_LENGTH ) {
        cell.detachEdge( edge );
      }

      // Flag out-of-bounds cells for removal
      if ( edge.start.x < 0 || edge.start.y < 0 || edge.start.x > width || edge.start.y > height ) {
        cell.flagForRemoval = true;
      }
    } );
  } );

  // TODO: This doesn't seem to be creating holes in the map like I want it to...
  for ( let i = 0; i < 10; i ++ ) {
    const cell = cells.find( e => e.getUnlinkedEdges().length > 2 );
    if ( cell ) {
      cell.flagForRemoval = true;
    }
  }

  cells = cells.filter( cell => { 
    if ( cell.flagForRemoval ) {
      cell.detachAll();
    }

    return !cell.flagForRemoval;
  } );

  
  function doMazeLink( current, previous ) {
    if ( current == null || current.edges.filter( e => e.linked ).length > 0 ) {
      return;
    }
    
    if ( previous ) {
      previous.linkTo( current );
    }
      
    const neighbors = current.edges.map( e => e.neighbor ).sort( ( a, b ) => Math.random() > 0.5 ? 1 : -1 );
    neighbors.forEach( next => doMazeLink( next, current ) );
  }
    
    doMazeLink( cells[ 0 ] );
    
    cells.forEach( cell => {
      if ( cell.edges.filter( e => e.linked ).length == 0 ) {
        cell.flagForRemoval = true;
      }
    } );
    
    // TODO: Don't do this twice
    cells = cells.filter( cell => { 
      if ( cell.flagForRemoval ) {
        cell.detachAll();
      }
      
    return !cell.flagForRemoval;
  } );
  
  const ctx = document.getElementById( 'canvas' ).getContext( '2d' );
  cells.forEach( seed => seed.draw( ctx ) );
  
  const points = [];
  
  let edge = cells[ 0 ].edges[ 0 ];
  const visited = new Set();
  
  while ( !visited.has( edge ) ) {
    visited.add( edge );
    
    points.push( {
      x: edge.start.x,
      y: edge.start.y,
    } );

    if ( Math.hypot( edge.end.x - edge.next.start.x, edge.end.y - edge.next.start.y ) > 10 ) {
      points.push( {
        x: edge.end.x,
        y: edge.end.y,
      } );
    }
    
    edge = edge.next;
  }

  // TODO: Don't get so hung up on curves, maybe just try breaking up lines and perturbing the points we have?
  
  // const curves = Curve.getLoopThroughPoints( points );
  // curves.forEach( curve => curve.draw( ctx ) );
  
  ctx.fillStyle = 'lime';
  points.forEach( point => ctx.fillRect( point.x - 2, point.y - 2, 4, 4 ) );

</script>