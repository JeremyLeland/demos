<title>Voronoi</title>
<link rel="stylesheet" href="../style.css">

<body>
  <canvas id="canvas" width="500px" height="500px"></canvas>
</body>

<script type="module">

  class Edge {
    start;
    end;
    neighbor;

    constructor( start, end, neighbor ) {
      this.start = start;
      this.end = end;
      this.neighbor = neighbor;
    }

    draw( ctx ) {
      ctx.beginPath();
      ctx.moveTo( this.start.x, this.start.y );
      ctx.lineTo( this.end.x, this.end.y );
      ctx.strokeStyle = 'dimgray';
      ctx.stroke();

      if ( this.neighbor ) {
        ctx.beginPath();
        ctx.moveTo( ( this.start.x + this.end.x ) / 2, ( this.start.y + this.end.y ) / 2 );
        ctx.lineTo( this.neighbor.center.x, this.neighbor.center.y );
        ctx.strokeStyle = this.linked ? 'darkgreen' : 'darkblue';
        ctx.stroke();
      }
    }
  }

  class Cell {
    x;
    y;
    center = { x: 0, y: 0 };
    edges = [];

    constructor( x, y ) {
      this.x = x;
      this.y = y;
    }

    setEdges( points, neighbors ) {
      points.forEach( point => {
        this.center.x += point.x;
        this.center.y += point.y;
      } );

      if ( points.length > 0 ) {
        this.center.x /= points.length;
        this.center.y /= points.length;
      }

      for ( let i = 0; i < points.length; i ++ ) {
        const current = points[ i ], next = points[ ( i + 1 ) % points.length ];
        this.edges.push( new Edge( current, next, neighbors[ i ] ) );
      }
    }

    draw( ctx ) {
      this.edges.forEach( edge => edge.draw( ctx ) );

      ctx.fillStyle = this.edges.length > 0 ? 'lime' : 'darkred';
      ctx.fillRect( this.x - 1, this.y - 1, 2, 2 );
      
      ctx.fillStyle = 'yellow';
      ctx.fillRect( this.center.x - 1, this.center.y - 1, 2, 2 );
    }
  }

  const size = 64, offset = 0.75 * size, cols = 8, rows = 8;

  const seeds = Array.from( 
    Array( cols ), ( _, col ) => Array.from( 
      Array( rows ), ( _, row ) => new Cell( 
        ( col + 0.5 ) * size + ( Math.random() - 0.5 ) * offset, 
        ( row + 0.5 ) * size + ( Math.random() - 0.5 ) * offset,
      )
    )
  );

  const ctx = document.getElementById( 'canvas' ).getContext( '2d' );

  // Prepare blacklist of neighbors to ignore (i.e. the edges)
  // const ignoreList = [];
  // for ( let col = 0; col < cols; col ++ ) {
  //   ignoreList.push( seeds[ col ][ 0 ], seeds[ col ][ rows - 1 ] );
  // }
  // for ( let row = 0; row < rows; row ++ ) {
  //   ignoreList.push( seeds[ 0 ][ row ], seeds[ cols - 1 ][ row ] );
  // }

  // Create middle cells
  for ( let row = 1; row < rows - 1; row ++ ) {
    for ( let col = 1; col < cols - 1; col ++ ) {
      const seed = seeds[ col ][ row ];
      const others = [ 
        seeds[ col - 1 ][ row - 1 ], seeds[ col ][ row - 1 ], seeds[ col + 1 ][ row - 1 ], 
        seeds[ col - 1 ][ row     ],                          seeds[ col + 1 ][ row     ], 
        seeds[ col - 1 ][ row + 1 ], seeds[ col ][ row + 1 ], seeds[ col + 1 ][ row + 1 ], 
      ];

      ctx.fillStyle = 'lime';
      ctx.fillRect( seed.x - 1, seed.y - 1, 2, 2 );

      const voronoi = getVoronoi( seed, others );

      seed.setEdges( 
        voronoi.points, 
        voronoi.neighbors /*.map( n => ignoreList.indexOf( n ) < 0 ? n : null )*/
      );
    }
  }

  for ( let row = 0; row < rows; row ++ ) {
    for ( let col = 0; col < cols; col ++ ) {
      const seed = seeds[ col ][ row ];
      seed.edges.forEach( edge => {
        if ( edge.neighbor.edges.length == 0 ) {
          edge.neighbor = null;
        }
      } );

      seed.draw( ctx );
    }
  }

  // TODO: Unlink edges below a certain length? (too small to use meaninfully)


  function getVoronoi( seed, others ) {
    let lines = others.map( other => {  
      const halfDist = Math.hypot( other.x - seed.x, other.y - seed.y ) / 2;
      const ang = Math.atan2( other.y - seed.y, other.x - seed.x );
      
      return {
        seed: other,
        dist: halfDist,
        point: {
          x: seed.x + Math.cos( ang ) * halfDist,
          y: seed.y + Math.sin( ang ) * halfDist,
        },
        slope: {
          x: -Math.sin( ang ),
          y:  Math.cos( ang ) 
        }
      };
    } );

    // TODO: Don't sort, just get closest
    lines.sort( ( a, b ) => a.dist - b.dist );
    
    const points = [], neighbors = [];

    const start = lines[ 0 ];
    let currentLine = start, previousLine = start;
    let currentPoint = currentLine.point;

    do {
      const intersections = [];
      lines.forEach( line => {
        if ( line != currentLine && line != previousLine ) {
          const dets = getDeterminants( { point: currentPoint, slope: currentLine.slope }, line );
            
          if ( 0 < dets.a ) {
            intersections.push( { line: line, det: dets.a } );
          }
        }
      } );

      if ( intersections.length == 0 ) {
        return { points: [], neighbors: [] }; // TODO: or null?
      }

      // TODO: Don't sort, just get closest
      intersections.sort( ( a, b ) => a.det - b.det );
      const closest = intersections[ 0 ];

      currentPoint = {
        x: currentPoint.x + currentLine.slope.x * closest.det,
        y: currentPoint.y + currentLine.slope.y * closest.det,
      };

      previousLine = currentLine;
      currentLine = closest.line;

      points.push( currentPoint );
      neighbors.push( currentLine.seed );
    }
    while ( currentLine != start );

    return { points: points, neighbors: neighbors };
  }

  // Based on: https://www.jeffreythompson.org/collision-detection/line-line.php
  function getDeterminants( a, b ) {
    // const D = ( ( y4 - y3 ) * ( x2 - x1 ) - ( x4 - x3 ) * ( y2 - y1 ) );

    // return {
    //   x: ( ( x4 - x3 ) * ( y1 - y3 ) - ( y4 - y3 ) * ( x1 - x3 ) ) / D,
    //   y: ( ( x2 - x1 ) * ( y1 - y3 ) - ( y2 - y1 ) * ( x1 - x3 ) ) / D,
    // }

    const D = b.slope.y * a.slope.x - b.slope.x * a.slope.y;

    return {
      a: ( b.slope.x * ( a.point.y - b.point.y ) - b.slope.y * ( a.point.x - b.point.x ) ) / D,
      b: ( a.slope.x * ( a.point.y - b.point.y ) - a.slope.y * ( a.point.x - b.point.x ) ) / D,
    }
  }

</script>