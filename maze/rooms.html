<title>Rooms</title>
<link rel="stylesheet" href="../style.css">

<body>
  <canvas id="canvas" width="800px" height="800px"></canvas>
</body>

<script type="module">
  import { Curve } from '../src/Curve.js';

  const CELL_SIZE = 64, OFFSET = 32, COLS = 10, ROWS = 10;

  class Edge {
    start;
    end;

    constructor( start, end ) {
      this.start = start;
      this.end = end;
    }

    coincidentWith( other ) {
      return this.start.x == other.end.x && this.start.y == other.end.y &&
        this.end.x == other.start.x && this.end.y == other.start.y;
    }

    draw( ctx ) {
      ctx.beginPath();
      ctx.moveTo( this.start.x, this.start.y );
      ctx.lineTo( this.end.x, this.end.y );

      ctx.strokeStyle = 'dimgray';
      ctx.stroke();
    }
  }

  class Cell {
    center = { x: 0, y: 0 };
    edges = [];
    neighbors = [];

    constructor( points ) {
      points.forEach( point => {
        this.center.x += point.x;
        this.center.y += point.y;
      } );
      this.center.x /= points.length;
      this.center.y /= points.length;

      for ( let i = 0; i < points.length; i ++ ) {
        const current = points[ i ], next = points[ ( i + 1 ) % points.length ];
        this.edges.push( new Edge( current, next ) );
      }
    }

    draw( ctx ) {
      this.edges.forEach( edge => edge.draw( ctx ) );
      
      ctx.beginPath();
      this.neighbors.forEach( neighbor => {
        ctx.moveTo( this.center.x, this.center.y );
        ctx.lineTo( neighbor.center.x, neighbor.center.y );
      } );
      ctx.strokeStyle = 'darkred';
      ctx.stroke();

      ctx.fillStyle = 'yellow';
      ctx.fillRect( this.center.x - 1, this.center.y - 1, 2, 2 );
    }
  }

  class Room {
    cells = [];
    edges = [];

    // TODO: Map< Edge, Cell> for neighbors?

    constructor( cell ) {
      this.cells.push( cell );
    }
  }

  const cellPoints = Array.from( 
    Array( COLS + 1 ), ( _, col ) => Array.from( 
      Array( ROWS + 1 ), ( _, row ) => ( { 
        x: col * CELL_SIZE + ( Math.random() - 0.5 ) * OFFSET, 
        y: row * CELL_SIZE + ( Math.random() - 0.5 ) * OFFSET,
      } ) 
    )
  );

  const cellGrid = Array.from( 
    Array( COLS ), ( _, col ) => Array.from( 
      Array( ROWS ), ( _, row ) => new Cell( [ 
        cellPoints[ col ][ row ], 
        cellPoints[ col ][ row + 1 ], 
        cellPoints[ col + 1 ][ row + 1 ], 
        cellPoints[ col + 1 ][ row ], 
      ] )
    )
  );

  for ( let row = 0; row < ROWS; row ++ ) {
    for ( let col = 0; col < COLS; col ++ ) {
      const cell = cellGrid[ col ][ row ];

      if ( col > 0 )  cell.neighbors.push( cellGrid[ col - 1 ][ row ] );
      if ( row < ROWS - 1 )  cell.neighbors.push( cellGrid[ col ][ row + 1 ] );
      if ( col < COLS - 1 )  cell.neighbors.push( cellGrid[ col + 1 ][ row ] );
      if ( row > 0 )  cell.neighbors.push( cellGrid[ col ][ row - 1 ] );
    }
  }

  const ctx = document.getElementById( 'canvas' ).getContext( '2d' );
  ctx.translate( CELL_SIZE / 2, CELL_SIZE / 2 );

  for ( let row = 0; row < ROWS; row ++ ) {
    for ( let col = 0; col < COLS; col ++ ) {
      cellGrid[ col ][ row ].draw( ctx );
    }
  }

  // const room1 = getRoom( 5, 5 );
  // const roomPoints = [ room1.NW, room1.SW, room1.SE, room1.NE ];

  // addRoom( roomPoints, getRoom( 5, 6 ) );
  // addRoom( roomPoints, getRoom( 6, 6 ) );
  // addRoom( roomPoints, getRoom( 4, 6 ) );
  // addRoom( roomPoints, getRoom( 5, 7 ) );
  // addRoom( roomPoints, getRoom( 5, 4 ) );
  // addRoom( roomPoints, getRoom( 6, 4 ) );

  // const curves = Curve.getLoopThroughPoints( roomPoints );
  // curves.forEach( curve => curve.draw( ctx ) );

  function addRoom( combined, room ) {
    const nwIndex = combined.indexOf( room.NW );
    const neIndex = combined.indexOf( room.NE );
    const swIndex = combined.indexOf( room.SW );
    const seIndex = combined.indexOf( room.SE );

    // North
    if ( swIndex >= 0 && seIndex >= 0 ) {
      combined.splice( seIndex + 1, 0, room.NE, room.NW );
    }
    // West
    if ( neIndex >= 0 && seIndex >= 0 ) {
      combined.splice( neIndex + 1, 0, room.NW, room.SW );
    }
    // South
    if ( nwIndex >= 0 && neIndex >= 0 ) {
      combined.splice( nwIndex + 1, 0, room.SW, room.SE );
    }
    // East
    if ( nwIndex >= 0 && swIndex >= 0 ) {
      combined.splice( swIndex + 1, 0, room.SE, room.NE );
    }
  }

  function getRoom( col, row ) {
    return {
      NW: cellPoints[ col ][ row ], 
      NE: cellPoints[ col + 1 ][ row ], 
      SW: cellPoints[ col ][ row + 1 ], 
      SE: cellPoints[ col + 1][ row + 1 ],
    };
  }

  function debugCells( cellPoints ) {
    for ( let row = 0; row < ROWS; row ++ ) {
      for ( let col = 0; col < COLS; col ++ ) {
        const NW = cellPoints[ col ][ row ];
        const NE = cellPoints[ col + 1 ][ row ];
        const SW = cellPoints[ col ][ row + 1 ];
        const SE = cellPoints[ col + 1 ][ row + 1 ];
        
        ctx.beginPath();
        [ NW, NE, SE, SW ].forEach( point => {
          ctx.lineTo( point.x, point.y );
        } );
        ctx.closePath();

        ctx.strokeStyle = 'dimgray';
        ctx.stroke();
      }
    }
  }

</script>
