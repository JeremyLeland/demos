<title>Rooms</title>
<link rel="stylesheet" href="../style.css">

<body>
  <canvas id="canvas" width="800px" height="800px"></canvas>
</body>

<script type="module">
  import { Curve } from '../src/Curve.js';

  class Edge {
    start;
    end;
    neighbor;
    linked = false;

    constructor( start, end ) {
      this.start = start;
      this.end = end;
    }

    coincidentWith( other ) {
      return this.start.x == other.end.x && this.start.y == other.end.y &&
        this.end.x == other.start.x && this.end.y == other.start.y;
    }

    draw( ctx ) {
      ctx.beginPath();
      ctx.moveTo( this.start.x, this.start.y );
      ctx.lineTo( this.end.x, this.end.y );
      ctx.strokeStyle = 'dimgray';
      ctx.stroke();

      if ( this.neighbor ) {
        ctx.beginPath();
        ctx.moveTo( ( this.start.x + this.end.x ) / 2, ( this.start.y + this.end.y ) / 2 );
        ctx.lineTo( this.neighbor.center.x, this.neighbor.center.y );
        ctx.strokeStyle = this.linked ? 'darkgreen' : 'darkblue';
        ctx.stroke();
      }
    }
  }

  class Cell {
    center = { x: 0, y: 0 };
    edges = [];

    constructor( points ) {
      points.forEach( point => {
        this.center.x += point.x;
        this.center.y += point.y;
      } );
      this.center.x /= points.length;
      this.center.y /= points.length;

      for ( let i = 0; i < points.length; i ++ ) {
        const current = points[ i ], next = points[ ( i + 1 ) % points.length ];
        this.edges.push( new Edge( current, next ) );
      }
    }

    draw( ctx ) {
      this.edges.forEach( edge => edge.draw( ctx ) );
      
      ctx.fillStyle = 'yellow';
      ctx.fillRect( this.center.x - 1, this.center.y - 1, 2, 2 );
    }

    linkTo( other ) {
      this.edges.find( edge => edge.neighbor == other ).linked = true;
    }

    static linkCells( a, b ) {
      a.linkTo( b );
      b.linkTo( a );
    }
  }

  function getCellGrid( cols, rows, size = 64, offset = 32 ) {
    const cellPoints = Array.from( 
      Array( cols + 1 ), ( _, col ) => Array.from( 
        Array( rows + 1 ), ( _, row ) => ( { 
          x: col * size + ( Math.random() - 0.5 ) * offset, 
          y: row * size + ( Math.random() - 0.5 ) * offset,
        } ) 
      )
    );

    const cellGrid = Array.from( 
      Array( cols ), ( _, col ) => Array.from( 
        Array( rows ), ( _, row ) => new Cell( [ 
          cellPoints[ col ][ row ], 
          cellPoints[ col ][ row + 1 ], 
          cellPoints[ col + 1 ][ row + 1 ], 
          cellPoints[ col + 1 ][ row ], 
        ] )
      )
    );

    for ( let row = 0; row < rows; row ++ ) {
      for ( let col = 0; col < cols; col ++ ) {
        const cell = cellGrid[ col ][ row ];

        if ( col > 0 )  cell.edges[ 0 ].neighbor = cellGrid[ col - 1 ][ row ];
        if ( row < rows - 1 )  cell.edges[ 1 ].neighbor = cellGrid[ col ][ row + 1 ];
        if ( col < cols - 1 )  cell.edges[ 2 ].neighbor = cellGrid[ col + 1 ][ row ];
        if ( row > 0 )  cell.edges[ 3 ].neighbor = cellGrid[ col ][ row - 1 ];
      }
    }

    return cellGrid;
  }

  const cellGrid = getCellGrid( 5, 5 );

  Cell.linkCells( cellGrid[ 1 ][ 1 ], cellGrid[ 1 ][ 0 ] );
  Cell.linkCells( cellGrid[ 1 ][ 1 ], cellGrid[ 0 ][ 1 ] );
  Cell.linkCells( cellGrid[ 1 ][ 1 ], cellGrid[ 2 ][ 1 ] );
  Cell.linkCells( cellGrid[ 1 ][ 1 ], cellGrid[ 1 ][ 2 ] );

  Cell.linkCells( cellGrid[ 1 ][ 2 ], cellGrid[ 2 ][ 2 ] );
  // Cell.linkCells( cellGrid[ 2 ][ 1 ], cellGrid[ 2 ][ 2 ] );
  

  const ctx = document.getElementById( 'canvas' ).getContext( '2d' );
  ctx.translate( 50, 50 );

  for ( let row = 0; row < cellGrid[ 0 ].length; row ++ ) {
    for ( let col = 0; col < cellGrid.length; col ++ ) {
      cellGrid[ col ][ row ].draw( ctx );
    }
  }

  const PADDING = 0.3;

  const points = new Set();

  let cell = cellGrid[ 1 ][ 0 ];

  drawCell( cell );

  function drawCell( current, prev, visited ) {
    visited ??= [];
    visited.push( current );

    let index = prev ? current.edges.findIndex( e => e.neighbor == prev ) : -1;
    for ( let i = 0; i < current.edges.length; i ++ ) {
      const edge = current.edges[ ++index % current.edges.length ];

      if ( edge.linked && visited.indexOf( edge.neighbor ) == -1 ) {
        drawCell( edge.neighbor, current, visited );
      }
      else if ( !edge.linked ) {
        points.add( {
          x: ( 1 - PADDING ) * edge.start.x + PADDING * current.center.x,
          y: ( 1 - PADDING ) * edge.start.y + PADDING * current.center.y,
        } );
        points.add( {
          x: ( 1 - PADDING ) * edge.end.x + PADDING * current.center.x,
          y: ( 1 - PADDING ) * edge.end.y + PADDING * current.center.y,
        } );
      }
    }

    visited.pop( current );
  }

  const pointsList = Array.from( points );

  const path = new Path2D( 'M ' + pointsList.map( e => e.x + ',' + e.y ).join(' L ') + ' Z' );
  ctx.strokeStyle = 'red';
  ctx.stroke( path );
  
  const curves = Curve.getLoopThroughPoints( pointsList );
  curves.forEach( curve => curve.draw( ctx, 0.2 ) );

</script>
