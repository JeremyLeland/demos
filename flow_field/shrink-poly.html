<title>Shrink polygons (removing lines as needed)</title>
<link rel="stylesheet" href="../grid.css">

<script type="module">
  import { Canvas } from './Canvas.js';
  import { Line } from './Line.js';

  
  const canvas = new Canvas();

  const SIZE = 10;

  const points = [
    [ 2, 2 ],
    [ 6, 1 ],
    [ 9, 6 ],
    [ 6, 8.2 ],
    [ 5.6, 8.2 ],
    [ 5, 8 ],
    [ 3, 6 ],
  ];

  canvas.draw = ( ctx ) => {
    ctx.scale( 1 / SIZE, 1 / SIZE );
    ctx.lineWidth = 2 * SIZE / canvas.scale;

    for ( let scale = 1; scale > -3; scale -= 0.1 ) {
      ctx.beginPath();
      scalePoly( points, scale ).forEach( p => ctx.lineTo( p[ 0 ], p[ 1 ] ) );
      ctx.closePath();

      ctx.strokeStyle = `rgb( ${ 255 - Math.abs( scale ) * 100 }, ${ 255 + scale * 200 }, 0 )`;
      ctx.stroke();
    }
  };

  canvas.redraw();

  function scalePoly( points, scale ) {
    const scaled = [];

    const info = [];

    let soonestLimit = scale;

    for ( let i = 0; i < points.length; i ++ ) {
      const prev = points.at( i - 1 );
      const curr = points[ i ];
      const next = points[ ( i + 1 ) % points.length ];
      const next2 = points[ ( i + 2 ) % points.length ];

      const prevNormalAngle = Math.atan2( prev[ 0 ] - curr[ 0 ], curr[ 1 ] - prev[ 1 ] );
      const normalAngle     = Math.atan2( curr[ 0 ] - next[ 0 ], next[ 1 ] - curr[ 1 ] );
      const nextNormalAngle = Math.atan2( next[ 0 ] - next2[ 0 ], next2[ 1 ] - next[ 1 ] );

      const ang1 = prevNormalAngle + deltaAngle( prevNormalAngle, normalAngle ) / 2;
      const ang2 = normalAngle + deltaAngle( normalAngle, nextNormalAngle ) / 2;

      const dx1 = Math.cos( ang1 );
      const dy1 = Math.sin( ang1 );
      const dx2 = Math.cos( ang2 );
      const dy2 = Math.sin( ang2 );

      // Find intersection of normals from both points of line
      // The cosine part is same as below, accounting for point movement being greater than scale value
      const u = ( dx2 * ( curr[ 1 ] - next[ 1 ] ) - dy2 * ( curr[ 0 ] - next[ 0 ] ) ) / ( dy2 * dx1 - dx2 * dy1 ) * Math.cos( deltaAngle( ang1, normalAngle ) );
      
      if ( u > soonestLimit ) {
        soonestLimit = u;
      }

      info.push( {
        lineNormal: normalAngle,
        pointNormal: ang1,
        limit: u,
      } );
    }

    for ( let i = 0; i < points.length; i ++ ) {
      if ( info[ i ].limit < soonestLimit ) {
        const H = soonestLimit / Math.cos( deltaAngle( info[ i ].pointNormal, info[ i ].lineNormal ) );
        
        scaled.push( [
          points[ i ][ 0 ] + Math.cos( info[ i ].pointNormal ) * H,
          points[ i ][ 1 ] + Math.sin( info[ i ].pointNormal ) * H,
        ] );
      }
    }

    if ( scale < soonestLimit ) {
      return scalePoly( scaled, scale - soonestLimit );
    }
    else {
      return scaled;
    }
  }

  function fixAngle( a ) {
    return a > Math.PI ? a - Math.PI * 2 : a < -Math.PI ? a + Math.PI * 2 : a;
  }

  function deltaAngle( a, b ) {
    return fixAngle( b - a );
  }

</script>