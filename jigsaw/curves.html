<title>Jigsaw-style curves</title>
<link rel="stylesheet" href="../style.css">

<style>
  .piece {
    position: absolute;
  }
</style>

<script type="module">
  import { Curve } from '../src/Curve.js';

  //const imageSrc = 'https://w0.peakpx.com/wallpaper/962/451/HD-wallpaper-red-poppies-painted-flowers-drawing-red-flowers-wild-flowers.jpg';
  const imageSrc = 'https://imagesvc.meredithcorp.io/v3/mm/image?url=https%3A%2F%2Fstatic.onecms.io%2Fwp-content%2Fuploads%2Fsites%2F37%2F2021%2F10%2F22%2Fpink-camellias.jpg';

  const POINTS_PER_SIDE = 6;
  const size = 200;

  // TODO: Randomize these for variety
  const NECK_WIDTH = 50, NECK_DEPTH = -10, HEAD_WIDTH = 60, HEAD_DEPTH = 30, TIP_DEPTH = 50;
  const NOTCH_OFFSET = 100;

  const cols = [], rows = [];
  const NUM_COLS = 4, NUM_ROWS = 3;

  for ( let col = 1; col < NUM_COLS; col ++ ) {
    const colPoints = [];

    for ( let row = 0; row < NUM_ROWS; row ++ ) {
      colPoints.push(
        { x: size * col, y: size * row },
        { x: size * col + NECK_DEPTH, y: size * row + NOTCH_OFFSET - NECK_WIDTH / 2 },
        { x: size * col + HEAD_DEPTH, y: size * row + NOTCH_OFFSET - HEAD_WIDTH / 2 },
        { x: size * col + TIP_DEPTH , y: size * row + NOTCH_OFFSET                  },
        { x: size * col + HEAD_DEPTH, y: size * row + NOTCH_OFFSET + HEAD_WIDTH / 2 },
        { x: size * col + NECK_DEPTH, y: size * row + NOTCH_OFFSET + NECK_WIDTH / 2 },
      );
    }

    colPoints.push( { x: size * col, y: size * NUM_ROWS } );

    cols.push( colPoints );
  }

  for ( let row = 1; row < NUM_ROWS; row ++ ) {
    const rowPoints = [];

    for ( let col = 0; col < NUM_COLS; col ++ ) {
      rowPoints.push(
        { x: size * col, y: size * row },
        { x: size * col + NOTCH_OFFSET - NECK_WIDTH / 2, y: size * row + NECK_DEPTH },
        { x: size * col + NOTCH_OFFSET - HEAD_WIDTH / 2, y: size * row + HEAD_DEPTH },
        { x: size * col + NOTCH_OFFSET                 , y: size * row + TIP_DEPTH  },
        { x: size * col + NOTCH_OFFSET + HEAD_WIDTH / 2, y: size * row + HEAD_DEPTH },
        { x: size * col + NOTCH_OFFSET + NECK_WIDTH / 2, y: size * row + NECK_DEPTH },
      );
    }

    rowPoints.push( { x: size * NUM_COLS, y: size * row } );

    rows.push( rowPoints );
  }

  for ( let row = 0; row < NUM_ROWS; row ++ ) {
    for ( let col = 0; col < NUM_COLS; col ++ ) {
      addPiece( col, row );
    }
  }
  
  function addPiece( col, row ) {
    const left   = col == 0            ? printLine( col    , row + 1 ) : printCurves( cols[ col - 1 ].slice( POINTS_PER_SIDE * row, 1 + POINTS_PER_SIDE * ( row + 1 ) ) );
    const bottom = row == NUM_ROWS - 1 ? printLine( col + 1, row + 1 ) : printCurves( rows[ row     ].slice( POINTS_PER_SIDE * col, 1 + POINTS_PER_SIDE * ( col + 1 ) ) );
    const right  = col == NUM_COLS - 1 ? printLine( col + 1, row     ) : printCurves( cols[ col     ].slice( POINTS_PER_SIDE * row, 1 + POINTS_PER_SIDE * ( row + 1 ) ).reverse() );
    const top    = row == 0            ? printLine( col    , row     ) : printCurves( rows[ row - 1 ].slice( POINTS_PER_SIDE * col, 1 + POINTS_PER_SIDE * ( col + 1 ) ).reverse() );
    
    const piece = document.createElement( 'img' );
    piece.className = 'piece';
    piece.src = imageSrc;
    piece.style.clipPath = 'path( \'' +
      `M ${ col * size },${ row * size } ` + 
      left + bottom + right + top +
    '\')';
    document.body.appendChild( piece );
  }

  function printLine( col, row ) {
    return `L ${ col * size },${ row * size } `;
  }

  function printCurves( points ) {
    const curves = Curve.getCurvesThroughPoints( points );

    return curves.map( 
      c => `C ${ printPoint( c.control1 ) } ${ printPoint( c.control2 ) } ${ printPoint( c.end ) }`
    ).join(' ');
  }

  function printPoint( p ) { return `${ p.x },${ p.y }`; }

</script>