<title>Spread out targets at goal</title>
<link rel="stylesheet" href="../style.css">

<script type="module">

import { Canvas } from '../src/Canvas.js';
import { Line } from '../src/Line.js';
import * as Util from '../src/Util.js';
import { ValuesPanel } from '../src/ValuesPanel.js';

const canvas = new Canvas();
canvas.backgroundColor = '#222';
canvas.zoom = 1 / 20;
canvas.scrollX = -10;
canvas.scrollY = -10;

const Constants = {
  Turn: {
    MaxSpeed: 0.01,
    Accel: 0.0001,
    CloseEnough: 1,
  },
  Move: {
    MaxSpeed: 0.01,
    Accel: 0.00001,
    CloseEnough: 0.1,
  },
  AvoidWeight: 0.01,
  WallWeight: 0.02
}
new ValuesPanel( Constants );

const entities = [];
const walls = [];

for ( let i = 0; i < 10; i ++ ) {
  entities.push( newEntity( 0, 0, 'orange' ) );
}

const loops = [
  [
    [ -6, -6 ],
    [ -5, 6 ],
    [ 5, 6 ],
    [ 6, -6 ],
  ],
  [
    [ 3, 3 ],
    [ 0.5, 0 ],
    [ 2.5, -2 ],
  ],
  [
    [ -3, 3 ],
    [ -2.5, -2 ],
    [ -0.5, 0 ],
  ],
];

loops.forEach( loop => {
  for ( let i = 0; i < loop.length; i ++ ) {
    walls.push( 
      new Line( ...loop[ i ], ...loop[ ( i + 1 ) % loop.length ] )
    );
  }
} );

updateGoal( { x: 0, y: 0 } );

function newEntity( x, y, color ) {
  return {
    x: x,
    y: y,
    angle: 0,
    turn: {
      speed: 0,
      accel: 0,
    },
    move: {
      speed: 0,
      accel: 0,
    },
    radius: 0.5, //0.2 + Math.random() * 0.2,
    fillStyle: color,
    target: {
      x: 0,
      y: 0,
    },
    goal: {
      x: 0,
      y: 0,
    },
  };
}

function doRotate( entity, dt ) {
  entity.angle += entity.turn.speed * dt + 0.5 * entity.turn.accel * dt ** 2;
  entity.turn.speed += entity.turn.accel * dt;
}

function doAccel( entity, dt, property, doFunc, distance, CONSTS ) {
  // Update in phases:
  //  1. Accelerating
  //  2. Max speed
  //  3. Deccelerating
  //  4. Stopped (don't update past this)

  const dir = distance < 0 ? -1 : 1;

  //
  // Accelerating
  //

  // Distance to accel from 0 to current speed + distance until target / 2 = total accel dist (and deccel dist)
  // Use this to find max acceleration we could acheive
  const distToCurrentSpeed = ( property.speed ** 2 - 0 ) / ( dir * 2 * CONSTS.Accel );
  const distToTheoreticalMaxSpeed = ( distToCurrentSpeed + distance ) / 2;
  const theoreticalMaxSpeed = Math.sqrt( 0 + 2 * CONSTS.Accel * Math.abs( distToTheoreticalMaxSpeed ) );
  const maxSpeed = dir * Math.min( theoreticalMaxSpeed, CONSTS.MaxSpeed );

  const distToMaxSpeed = ( maxSpeed ** 2 - property.speed ** 2 ) / ( dir * 2 * CONSTS.Accel );
  const timeUntilMaxSpeed = ( maxSpeed - property.speed ) / ( dir * CONSTS.Accel );
  
  if ( dt > 0 ) {
    if ( timeUntilMaxSpeed > 0 ) {
      property.accel = dir * CONSTS.Accel;

      const updateTime = Math.min( timeUntilMaxSpeed, dt );

      // console.log( `Acclerating for ${ updateTime } (timeUntilMaxSpeed = ${ timeUntilMaxSpeed })` );

      doFunc( entity, updateTime );
      dt -= updateTime;
    }
  }

  //
  // Cruising at max speed
  //
  if ( dt > 0 ) {
    const brakeDist = ( 0 - maxSpeed ** 2 ) / ( -dir * 2 * CONSTS.Accel );
    const distToBrake = distance - distToMaxSpeed - brakeDist;
    const timeUntilBrake = distToBrake / property.speed;
    
    if ( timeUntilBrake > 0 ) {
      property.accel = 0;

      const updateTime = Math.min( timeUntilBrake, dt );

      // console.log( `Cruising at ${ maxSpeed } for ${ updateTime } (timeUntilBrake = ${ timeUntilBrake })` );

      doFunc( entity, updateTime );
      dt -= updateTime;
    }
  }

  //
  // Deccelerating
  //
  if ( dt > 0 ) {
    const timeUntilStopped = ( 0 - property.speed ) / ( -dir * CONSTS.Accel );
    
    if ( timeUntilStopped > 0 ) {
      property.accel = -dir * CONSTS.Accel;

      const updateTime = Math.min( timeUntilStopped, dt );

      // console.log( `Deccelerating for ${ updateTime } (timeUntilStopped = ${ timeUntilStopped })` );

      doFunc( entity, updateTime );
      dt -= updateTime;
    }
  }
  
  // console.log( `After updates, dt = ${ dt } and entity = ${ JSON.stringify( entity ) }` );
}

function doMove( entity, dt ) {
  const moveDist = entity.move.speed * dt + 0.5 * entity.move.accel * dt ** 2;
  entity.x += Math.cos( entity.angle ) * moveDist;
  entity.y += Math.sin( entity.angle ) * moveDist;
  
  entity.move.speed += entity.move.accel * dt;
}

function moveEntity( entity, dt ) {

}

canvas.update = ( dt ) => {
  //
  // Adjust targets
  //

  entities.forEach( entity => {
    let dx = 0;
    let dy = 0;

    // TODO: Does it make a meaningful difference if we do this before or after entities?
    walls.forEach( wall => {
      const angle = wall.normalAngle;
      const dist = wall.distanceFrom( entity.target.x, entity.target.y, entity.radius );

      const goalDist = wall.distanceFrom( entity.goal.x, entity.goal.y, entity.radius );

      if ( -2 * entity.radius < dist && dist < 0 ) {
      // Only count wall if it comes between us and goal
      // if ( dist < 0 && Math.sign( goalDist ) != Math.sign( dist ) ) {
        const val = dist * Constants.WallWeight;

        dx -= Math.cos( angle ) * val;
        dy -= Math.sin( angle ) * val;
      }

    } );

    entities.filter( other => entity != other ).forEach( other => {
      const cx = other.target.x - entity.target.x;
      const cy = other.target.y - entity.target.y;
      const angle = Math.atan2( cy, cx );
      const dist = Math.hypot( cx, cy ) - entity.radius - other.radius;

      const val = Math.min( 0, dist ) * Constants.AvoidWeight;
        
      dx += Math.cos( angle ) * val;
      dy += Math.sin( angle ) * val;
    } );

    // loops.forEach( loop => {
    //   let bestNormalAngle, bestDist = -Infinity;

    //   for ( let i = 0; i < loop.length; i ++ ) {
    //     const current = loop[ i ];
    //     const next = loop[ ( i + 1 ) % loop.length ];

    //     const normalAngle = Math.atan2( current[ 0 ] - next[ 0 ], next[ 1 ] - current[ 1 ] );
    //     const dist = distanceFromLine( ...current, ...next, entity.target.x, entity.target.y, entity.radius );

    //     if ( dist > bestDist ) {
    //       bestNormalAngle = normalAngle;
    //       bestDist = dist;
    //     }
    //   }

    //   if ( bestDist < 0 ) {
    //     const val = bestDist * Constants.WallWeight;

    //     dx -= Math.cos( bestNormalAngle ) * val;
    //     dy -= Math.sin( bestNormalAngle ) * val;
    //   }
    // } );
    
    
    entity.target.x += dx * dt;
    entity.target.y += dy * dt;
  } );

  //
  // Move toward targets
  //
  entities.forEach( entity => {
    const tx = entity.target.x - entity.x;
    const ty = entity.target.y - entity.y;
    const targetAngle = Math.atan2( ty, tx );
    const targetDist = Math.hypot( tx, ty );

    const targetAngleDelta = Util.deltaAngle( entity.angle, targetAngle );

    // TODO: Don't use constants object, give it max speed and accel separately (so we can adjust max speed)
    //       This will let us adjust speed based on our angle to the target
    //       We'll need to support slowing down if maxSpeed is less than current speed
    doAccel( entity, dt, entity.turn, doRotate, targetAngleDelta, Constants.Turn );

    if ( targetDist > 0.01 ) {
      doAccel( entity, dt, entity.move, doMove, targetDist, Constants.Move );
    }

  } );
}

canvas.draw = ( ctx ) => {
  ctx.lineWidth = 0.002 / canvas.zoom;

  ctx.strokeStyle = '#ff8';
  // loops.forEach( loop => {
  //   for ( let i = 0; i < loop.length; i ++ ) {
  //     const current = loop[ i ];
  //     const next = loop[ ( i + 1 ) % loop.length ];

  //     drawLine( ctx, ...current, ...next );
  //   }
  // } );
  walls.forEach( wall => wall.draw( ctx ) );

  entities.forEach( entity => drawEntity( ctx, entity ) );
}

const entityPath = new Path2D();
entityPath.moveTo( 1, 0 );
entityPath.arc( 0, 0, 1, 2, -2 );
entityPath.closePath();

function drawEntity( ctx, entity ) {
  ctx.translate( entity.x, entity.y );
  ctx.rotate( entity.angle );
  ctx.scale( entity.radius, entity.radius ); {
    ctx.fillStyle = entity.fillStyle;
    ctx.fill( entityPath );
    ctx.strokeStyle = 'black';
    ctx.stroke( entityPath );
  }
  ctx.scale( 1 / entity.radius, 1 / entity.radius );
  ctx.rotate( -entity.angle );
  ctx.translate( -entity.x, -entity.y );


  // Draw target
  ctx.strokeStyle = entity.fillStyle;

  ctx.beginPath();
  ctx.moveTo( entity.x, entity.y );
  ctx.lineTo( entity.target.x, entity.target.y );
  ctx.stroke();
  
  ctx.beginPath();
  ctx.arc( entity.target.x, entity.target.y, entity.radius, 0, Math.PI * 2 );
  ctx.stroke();

  // Draw goal
  ctx.fillStyle = ctx.strokeStyle = 'gray';

  ctx.beginPath();
  ctx.moveTo( entity.x, entity.y );
  ctx.lineTo( entity.goal.x, entity.goal.y );
  ctx.stroke();
  
  ctx.beginPath();
  ctx.arc( entity.goal.x, entity.goal.y, 0.1, 0, Math.PI * 2 );
  ctx.fill();
}

function drawLine( ctx, x1, y1, x2, y2 ) {
  ctx.beginPath();
  ctx.moveTo( x1, y1 );
  ctx.lineTo( x2, y2 );
  // ctx.lineWidth = 1;
  ctx.stroke();

  const midX = ( x1 + x2 ) / 2;
  const midY = ( y1 + y2 ) / 2;
  const normalAngle = Math.atan2( x1 - x2, y2 - y1 );
  const NORM_LEN = 0.5;

  ctx.beginPath();
  ctx.moveTo( midX, midY );
  ctx.lineTo( 
    midX + Math.cos( normalAngle ) * NORM_LEN, 
    midY + Math.sin( normalAngle ) * NORM_LEN,
  );
  ctx.lineWidth /= 2;
  ctx.stroke();
  ctx.lineWidth *= 2;
}

function distanceFromLine( x1, y1, x2, y2, x, y, radius ) {
  const px = x2 - x1;
  const py = y2 - y1;
  const D = ( px * px ) + ( py * py );

  const len = Math.sqrt( D );
  const normX = py / len;
  const normY = -px / len;
  
  const u = ( ( x - x1 ) * px + ( y - y1 ) * py ) / D;
  const offset = radius / len;

  // TODO: Offset treats entity as a square, how would we make it a circle?

  if ( u + offset <= 0 ) {
    return Math.hypot( x - x1, y - y1 ) - radius;
  }
  else if ( 1 <= u - offset ) {
    return Math.hypot( x - x2, y - y2 ) - radius;
  }
  else {
    return ( x - x1 ) * normX + ( y - y1 ) * normY - radius;
  }
}

canvas.start();

function updateGoal( p ) {
  entities.forEach( ( e, index ) => {

    // Can use offset to have some control of where we end up relative to each other
    // Try to avoid the lines by spacing people out a little

    // Offset based on initial position
    // const offsetX = e.target.x - e.goal.x;
    // const offsetY = e.target.y - e.goal.y;

    // Offset in a small circle
    const angle = Math.PI * 2 * index / entities.length;
    const dist = 0.1;
    const offsetX = Math.cos( angle ) * dist;
    const offsetY = Math.sin( angle ) * dist;


    e.goal.x = p.x;
    e.goal.y = p.y;

    // Start target at goal, then spread out during updates
    e.target.x = e.goal.x + offsetX;
    e.target.y = e.goal.y + offsetY;
  } );
}

canvas.pointerDown = ( p ) => {
  if ( p.buttons == 1 ) {
    updateGoal( p );
  }
  else {
    entities.push( newEntity( p.x, p.y, 'orange' ) );
  }
}

canvas.pointerMove = ( p ) => {
  if ( p.buttons == 1 ) {
    updateGoal( p );
  }
  else if ( p.buttons == 2 ) {
    entities.push( newEntity( p.x, p.y, 'orange' ) );
  }
}

canvas.pointerUp = ( p ) => {
}

// document.addEventListener( 'keydown', e => {
//   canvas.update( 10 );
//   canvas.redraw();
// } );

</script>