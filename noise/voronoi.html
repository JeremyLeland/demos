<title>Voronoi</title>
<link rel="stylesheet" href="../style.css">

<body>
  <canvas id="canvas" width="500px" height="500px"></canvas>
</body>

<script type="module">
  const size = 128, offset = 0.8 * size, cols = 3, rows = 3;

  const seeds = Array.from( 
    Array( cols ), ( _, col ) => Array.from( 
      Array( rows ), ( _, row ) => ( { 
        x: ( col + 0.5 ) * size + ( Math.random() - 0.5 ) * offset, 
        y: ( row + 0.5 ) * size + ( Math.random() - 0.5 ) * offset,
      } ) 
    )
  );

  const ctx = document.getElementById( 'canvas' ).getContext( '2d' );

  
  ctx.strokeStyle = 'dimgray';
  ctx.fillStyle = 'white';
  for ( let row = 0; row < rows; row ++ ) {
    for ( let col = 0; col < cols; col ++ ) {
      const seed = seeds[ col ][ row ];
      ctx.strokeRect( col * size, row * size, size, size );
      ctx.fillRect( seed.x - 1, seed.y - 1, 2, 2 );
    }
  }

  let seedCol = 1, seedRow = 1, seed = seeds[ seedCol ][ seedRow ];

  const colors = [ 'red', 'orange', 'yellow', 'green', 'blue', 'purple', 'brown', 'gray' ];

  let lines = [];

  for ( let row = Math.max( 0, seedRow - 1 ); row <= Math.min( rows - 1, seedRow + 1 ); row ++ ) {
    for ( let col = Math.max( 0, seedCol - 1 ); col <= Math.min( rows - 1, seedCol + 1 ); col ++ ) {
      if ( col == seedCol && row == seedRow ) {
        continue;
      }
      
      const otherSeed = seeds[ col ][ row ];
      
      const halfDist = Math.hypot( otherSeed.x - seed.x, otherSeed.y - seed.y ) / 2;
      const ang = Math.atan2( otherSeed.y - seed.y, otherSeed.x - seed.x );
      
      lines.push( {
        dist: halfDist,
        point: {
          x: seed.x + Math.cos( ang ) * halfDist,
          y: seed.y + Math.sin( ang ) * halfDist,
        },
        slope: {
          x: -Math.sin( ang ),
          y:  Math.cos( ang ) 
        }
      } );
    }
  }

  lines.sort( ( a, b ) => a.dist - b.dist );

  lines.forEach( ( line, index ) => {
    ctx.strokeStyle = colors[ index ];
    ctx.beginPath();
    ctx.moveTo( line.point.x - line.slope.x * size, line.point.y - line.slope.y * size );
    ctx.lineTo( line.point.x + line.slope.x * size, line.point.y + line.slope.y * size );
    ctx.stroke();
  } );

  const start = lines[ 0 ];
  let current = start, previous = start;
  let point = current.point;

  const points = [];

  let tries = 0;

  do {
    const intersections = [];
    lines.forEach( line => {
      if ( current != line && previous != line ) {
        const dets = getDeterminants( { point: point, slope: current.slope }, line );
        
        if ( 0 < dets.a ) {
          intersections.push( { line: line, det: dets.a } );
        }
      }
    } );
    intersections.sort( ( a, b ) => a.det - b.det );
    const closest = intersections[ 0 ];

    point = {
      x: point.x + current.slope.x * closest.det,
      y: point.y + current.slope.y * closest.det,
    };

    points.push( point );

    previous = current;
    current = closest.line;
  }
  while ( current != start && ++tries < 10 );

  ctx.fillStyle = 'lime';
  points.forEach( point => ctx.fillRect( point.x - 2, point.y - 2, 4, 4 ) );


  // Based on: https://www.jeffreythompson.org/collision-detection/line-line.php
  function getDeterminants( a, b ) {
    // const D = ( ( y4 - y3 ) * ( x2 - x1 ) - ( x4 - x3 ) * ( y2 - y1 ) );

    // return {
    //   x: ( ( x4 - x3 ) * ( y1 - y3 ) - ( y4 - y3 ) * ( x1 - x3 ) ) / D,
    //   y: ( ( x2 - x1 ) * ( y1 - y3 ) - ( y2 - y1 ) * ( x1 - x3 ) ) / D,
    // }

    const D = b.slope.y * a.slope.x - b.slope.x * a.slope.y;

    return {
      a: ( b.slope.x * ( a.point.y - b.point.y ) - b.slope.y * ( a.point.x - b.point.x ) ) / D,
      b: ( a.slope.x * ( a.point.y - b.point.y ) - a.slope.y * ( a.point.x - b.point.x ) ) / D,
    }
  }


</script>