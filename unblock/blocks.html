<title>Unblock v0.5</title>
<meta name="viewport" content="width=device-width, user-scalable=no">

<!--
  NOTE: The 'border-style: outset' that I use for the block effect
        doesn't work well with small values. To get around this, I 
        am giving everything a size of 10 (instead of just using 1
        for everything, which would be cleaner).
-->

<style>
  body {
    margin: 0;
    overscroll-behavior: none; /* Disable Chrome two fingers back/forward swipe */
    user-select: none;  /* Prevent accidental selection while dragging mouse */
    touch-action: none;

    display: flex;
    align-items: center;
    justify-content: center;
    height: 100%;
  }
  
  #arena {
    margin-left: auto;
    margin-right: auto;
    background-color: darkslategrey;

    width: 60;
    height: 60;
  }

  #victory {
    position: absolute;
    top: 50%;
    width: 100%;
    text-align: center;
    font-family: sans-serif;
    font-size: 50;
    visibility: hidden;
  }

  .block {
    position: absolute;
    border-style: outset;
    border-width: 1;
    border-color: #0006;
    box-sizing: border-box;  /* keep border inside div */
  }

</style>

<body>
  <div id="arena"></div>
  <div id="victory">Victory!</div>
</body>

<script>
  document.addEventListener( 'mousedown',  inputStart );
  document.addEventListener( 'touchstart', inputStart );
  document.addEventListener( 'mousemove', inputMove );
  document.addEventListener( 'touchmove', inputMove );
  document.addEventListener( 'mouseup',  inputStop );
  document.addEventListener( 'touchend', inputStop );

  const ARENA_SIZE = 6;
  const EXIT_ROW = 2;

  const victoryDiv = document.getElementById( 'victory' );

  const arenaDiv = document.getElementById( 'arena' );

  const Direction = { Horizontal: { x: 1, y: 0 }, Vertical: { x: 0, y: 1 } };
  const BlockType = {
    Primary:     { width: 2, height: 1, direction: Direction.Horizontal, color: 'red'    },
    Horizontal2: { width: 2, height: 1, direction: Direction.Horizontal, color: 'yellow' },
    Horizontal3: { width: 3, height: 1, direction: Direction.Horizontal, color: 'pink'   },
    Vertical2:   { width: 1, height: 2, direction: Direction.Vertical,   color: 'cyan'   },
    Vertical3:   { width: 1, height: 3, direction: Direction.Vertical,   color: 'green'  },
  }

  class Block {
    x = 0;
    y = 0;
    width = 0;
    height = 0;
    direction = Direction.Horizontal;
    color = 'white';
    
    #div;

    constructor( values ) {
      Object.assign( this, values );

      const isPrimary = this.y == EXIT_ROW && this.height == 1;

      this.#div = document.createElement( 'div' );
      this.#div.className = 'block';// + ( isPrimary ? 'primary' : `cols${ this.width }rows${ this.height }` );
      this.#div.style.width = this.width * 10;
      this.#div.style.height = this.height * 10;
      this.#div.style.backgroundColor = this.color;
      this.#div.owner = this;
      
      this.updateDiv();

      arenaDiv.appendChild( this.#div );
    }

    get left()    { return this.x; }
    get right()   { return this.x + this.width; }
    get top()     { return this.y; }
    get bottom()  { return this.y + this.height; }

    updateDiv() {
      this.#div.style.transform = `translate( ${ this.x * 10 }px,${ this.y * 10 }px )`;
    }
  }

  const level = [
    { col: 1, row: 2, type: 'Primary' },
    { col: 0, row: 0, type: 'Horizontal2' },
    { col: 2, row: 0, type: 'Vertical2' },
    { col: 5, row: 1, type: 'Vertical3' },
    { col: 2, row: 4, type: 'Horizontal3' },
  ];

  

  const blocks = Array.from( level, e => 
    new Block( Object.assign( { x: e.col, y: e.row }, BlockType[ e.type ] ) )
  );

  function newGame() {
    victoryDiv.style.visibility = 'hidden';
  }

  function victory() {
    victoryDiv.style.visibility = 'visible';
  }

  let active, lastX, lastY, scale;
  function inputStart( e ) {
    if ( e.target.owner ) {
      active = e.target.owner;

      const pos = e.touches?.[ 0 ] ?? e;
      lastX = pos.pageX;
      lastY = pos.pageY;
    }
  }

  function inputMove( e ) {
    if ( active ) {
      const pos = e.touches?.[ 0 ] ?? e;
      const dx = ( pos.pageX - lastX ) / 10 / scale;
      const dy = ( pos.pageY - lastY ) / 10 / scale;
      lastX = pos.pageX;
      lastY = pos.pageY;

      let minX = 0;
      let minY = 0;
      let maxX = Math.floor( active.y ) == EXIT_ROW ? Infinity : ARENA_SIZE - active.width;
      let maxY = ARENA_SIZE - active.height;

      blocks.filter( e => e != active ).forEach( other => {
        if ( ( other.top < active.top && active.top < other.bottom ) ||
             ( other.top < active.bottom && active.bottom < other.bottom ) ) {
          const left = other.x + other.width;
          if ( left <= active.x )   minX = Math.max( left, minX );

          const right  = other.x - active.width;
          if ( active.x <= right  ) maxX = Math.min( right,  maxX );
        }

        if ( ( other.left < active.left && active.left < other.right ) ||
             ( other.left < active.right && active.right < other.right ) ) {
          const top  = other.y + other.height;
          if ( top  <= active.y )   minY = Math.max( top,  minY );

          const bottom = other.y - active.height;
          if ( active.y <= bottom ) maxY = Math.min( bottom, maxY );
        }
      } );

      active.x = Math.max( minX, Math.min( maxX, active.x + active.direction.x * dx ) );
      active.y = Math.max( minY, Math.min( maxY, active.y + active.direction.y * dy ) );

      active.updateDiv();
    }
  }

  function inputStop( e ) {
    if ( active ) {
      active.x = Math.round( active.x );
      active.y = Math.round( active.y );
      active.updateDiv();
  
      if ( active.x >= ARENA_SIZE ) {
        victory();
      }
  
      active = null;
    }
  }

  window.onresize = () => {
    scale = Math.min( window.innerWidth, window.innerHeight ) / 60;
    arenaDiv.style.scale = scale;
  }
  window.onresize();

</script>