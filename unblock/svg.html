<style>
  body {
    margin: 0;
    overscroll-behavior: none; /* Disable Chrome two fingers back/forward swipe */
    user-select: none;  /* Prevent accidental selection while dragging mouse */
  }

  svg {
    width: 100%;
    height: 100%;
  }

  #victory {
    font-family: sans-serif;
    font-weight: bold;
    font-size: 1;
    fill: white;
    text-shadow: black 4px 4px;
    text-anchor: middle;
    /* dominant-baseline: middle; */  /* valid CSS, but I'm tired of the VS Code warning */
    visibility: hidden;
  }

</style>

<svg id="main" viewBox="0 0 6 6" preserveAspectRatio="xMidYMin">
  <defs id="defs">
    <rect id="primary"    width="2" height="1" fill="red"></rect>
    <rect id="cols2rows1" width="2" height="1" fill="yellow"></rect>
    <rect id="cols3rows1" width="3" height="1" fill="pink"></rect>
    <rect id="cols1rows2" width="1" height="2" fill="cyan"></rect>
    <rect id="cols1rows3" width="1" height="3" fill="green"></rect>
  </defs>
  <filter id="shadow">
    <feDropShadow dx="0.04" dy="0.04" stdDeviation="0"/>
  </filter>
  <rect id="arena" x="0" y="0" width="6" height="6" fill="darkslategray"></rect>
  <g id="blocks" filter="url(#shadow)">
  </g>
  <text id="victory" x="3" y="3" dominant-baseline="middle">Victory!</text>
</svg>

<script>
  const ARENA_SIZE = 6;
  const EXIT_ROW = 2;

  const SVG_NS = 'http://www.w3.org/2000/svg';
  const svg = document.getElementById( 'main' );
  const blocksSvg = document.getElementById( 'blocks' );
  const victorySvg = document.getElementById( 'victory' );

  class Block {
    x = 0;
    y = 0;
    width = 1;
    height = 1;

    #svg;

    constructor( { col, row, cols, rows } ) {
      this.x = col;
      this.y = row;
      this.width = cols;
      this.height = rows;

      const isPrimary = row == EXIT_ROW && rows == 1;

      this.#svg = document.createElementNS( SVG_NS, 'use' );
      this.#svg.setAttribute( 'href', isPrimary ? '#primary' : `#cols${ cols }rows${ rows }` );
      this.#svg.owner = this;
      
      this.#updateSvg();

      blocksSvg.appendChild( this.#svg );
    }

    center() { 
      return {
        x: this.x + this.width / 2, 
        y: this.y + this.height / 2, 
      };
    }

    getMoveBounds( others ) {
      const bounds = {
        minX: 0, 
        minY: 0,
        maxX: Math.floor( this.y ) == EXIT_ROW ? Infinity : ARENA_SIZE - this.width,
        maxY: ARENA_SIZE - this.height,
      }
      
      const thisCenter = this.center();
      others.filter( e => e != this ).forEach( other => {
        const otherCenter = other.center();

        if ( Math.abs( otherCenter.y - thisCenter.y ) < ( this.height + other.height ) / 2 ) {
          const left = other.x + other.width;
          if ( left <= this.x )   bounds.minX = Math.max( left, bounds.minX );

          const right = other.x - this.width;
          if ( this.x <= right  ) bounds.maxX = Math.min( right, bounds.maxX );
        }

        if ( Math.abs( otherCenter.x - thisCenter.x ) < ( this.width + other.width ) / 2 ) {
          const top = other.y + other.height;
          if ( top  <= this.y )   bounds.minY = Math.max( top, bounds.minY );

          const bottom = other.y - this.height;
          if ( this.y <= bottom ) bounds.maxY = Math.min( bottom, bounds.maxY );
        }
      } );

      return bounds;
    }

    move( dx, dy, moveBounds ) {
      if ( this.height == 1 ) {
        this.x = Math.max( moveBounds.minX, Math.min( moveBounds.maxX, this.x + dx ) );
      }
      if ( this.width == 1 ) {
        this.y = Math.max( moveBounds.minY, Math.min( moveBounds.maxY, this.y + dy ) );
      }

      this.#updateSvg();
    }

    stopMove() {
      this.x = Math.round( this.x );
      this.y = Math.round( this.y );
      this.#updateSvg();
    }

    #updateSvg() {
      this.#svg.style.transform = `translate( ${ this.x }px,${ this.y }px )`;
    }
  }

  const blocks = [
    { col: 1, row: 2, cols: 2, rows: 1 },
    { col: 0, row: 3, cols: 2, rows: 1 },
    { col: 2, row: 1, cols: 3, rows: 1 },
    { col: 0, row: 0, cols: 1, rows: 3 },
    { col: 5, row: 4, cols: 1, rows: 2 },
  ].map( e => new Block( e ) );

  function checkVictory() {
    if ( active.x >= ARENA_SIZE ) {
      victorySvg.style.visibility = 'visible';
    }
  }


  let active, moveBounds, lastPos;
  function inputStart( e ) {
    if ( e.target.owner ) {
      lastPos = getSVGPoint( e );

      active = e.target.owner;
      moveBounds = active.getMoveBounds( blocks );
    }
  }

  function inputMove( e ) {
    if ( active ) {
      const pos = getSVGPoint( e );
      const dx = pos.x - lastPos.x;
      const dy = pos.y - lastPos.y;
      lastPos = pos;

      active.move( dx, dy, moveBounds );      
    }
  }

  function inputStop( e ) {
    if ( active ) {
      active.stopMove();
      
      checkVictory();

      active = null;
    }
  }

  function getSVGPoint( e ) {
    const pos = e.touches?.[ 0 ] ?? e;
    const pt = svg.createSVGPoint();
    pt.x = pos.pageX;
    pt.y = pos.pageY;
    return pt.matrixTransform( svg.getScreenCTM().inverse() );
  }

  document.addEventListener( 'mousedown',  inputStart );
  document.addEventListener( 'touchstart', inputStart );
  document.addEventListener( 'mousemove', inputMove );
  document.addEventListener( 'touchmove', inputMove );
  document.addEventListener( 'mouseup',  inputStop );
  document.addEventListener( 'touchend', inputStop );
</script>