<link rel="stylesheet" href="../style.css">

<canvas id="canvas" width="800" height="600"></canvas>

<script type="module">

  // TODO: Settings object, changeable by dat.UI

  const ctx = document.getElementById( 'canvas' ).getContext( '2d' );

  const sphere = {
    pos: { x: 1, y: 1, z: 1 },
    radius: 1
  };

  function getValue( x, y ) {
    // const val = Math.max( 0, Math.sin( 0.02 * ( x + y ) ) ) * 255;

    const cols = ctx.canvas.width;
    const rows = ctx.canvas.height;

    const aspectRatio = cols / rows;
    const FOV = Math.PI * ( 1 / 3 );

    // TODO: How to handle this for non-square views?
    // TODO: This seems distorted at the edges
    const u = ( ( x + 0.5 ) / cols - 0.5 ) * FOV * aspectRatio;
    const v = ( 1 - ( y + 0.5 ) / rows - 0.5 ) * FOV;

    const dist = Math.hypot( Math.sin( u ), Math.sin( v ), 1 );

    const ray = {
      pos: {
        x: 0,
        y: 0,
        z: -4,
      },
      dir: {
        x: Math.sin( u ) / dist, 
        y: Math.sin( v ) / dist, 
        z: 1 / dist,
      },
    }

    const hitTime = intersect( ray, sphere );

    const hitPoint = {
      x: ray.pos.x + ray.dir.x * hitTime,
      y: ray.pos.y + ray.dir.y * hitTime,
      z: ray.pos.z + ray.dir.z * hitTime,
    };

    const hitNormal = {
      x: hitPoint.x - sphere.pos.x,
      y: hitPoint.y - sphere.pos.y,
      z: hitPoint.z - sphere.pos.z,
    };

    const normalLen = Math.hypot( hitNormal.x, hitNormal.y, hitNormal.z );
    hitNormal.x /= normalLen;
    hitNormal.y /= normalLen;
    hitNormal.z /= normalLen;

    // const val = hitTime < Infinity ? 255 : 0;
    if ( hitTime < Infinity ) {

      const val = Math.max( 0, hitNormal.x * ray.dir.x + hitNormal.y * ray.dir.y + hitNormal.z * ray.dir.z ) * 255;
 
      return ( 255 << 24 ) | ( val << 16 ) | ( val << 8 ) | val;
    }
    else {
      return 0;
    }
  }

  function drawValues( valFunc ) {
    const timeStr = `Drawing values`;
    console.time( timeStr );

    const cols = ctx.canvas.width;
    const rows = ctx.canvas.height;

    const imageData = ctx.getImageData( 0, 0, cols, rows );

    const buf = new ArrayBuffer( imageData.data.length );
    const buf8 = new Uint8ClampedArray( buf );
    const data = new Uint32Array( buf );

    let index = 0;
    for ( var y = 0; y < rows; y ++ ) {
      for ( var x = 0; x < cols; x ++ ) {
        data[ index ++ ] = valFunc( x, y );
      }
    }

    imageData.data.set( buf8 );
    ctx.putImageData( imageData, 0, 0 );

    console.timeEnd( timeStr );
  }

  drawValues( getValue );

  // See https://www.scratchapixel.com/lessons/3d-basic-rendering/minimal-ray-tracer-rendering-simple-shapes/ray-sphere-intersection

  function intersect( ray, sphere ) {

    const L = {
      x: ray.pos.x - sphere.pos.x,
      y: ray.pos.y - sphere.pos.y,
      z: ray.pos.z - sphere.pos.z,
    };

    const a = 1;//ray.dir.x * ray.dir.x + ray.dir.y * ray.dir.y + ray.dir.z * ray.dir.z;  // can be 1 if dir is normalized
    const b = 2 * ( ray.dir.x * L.x + ray.dir.y * L.y + ray.dir.z * L.z );
    const c = L.x * L.x + L.y * L.y + L.z * L.z - sphere.radius * sphere.radius;
    

    // Vec3f L = orig - center; 
    // float a = dir.dotProduct(dir); 
    // float b = 2 * dir.dotProduct(L); 
    // float c = L.dotProduct(L) - radius2;


    const t = solveQuadratic(a, b, c );

    return t;
  }

  // https://mathworld.wolfram.com/QuadraticEquation.html
  function solveQuadratic( a, b, c ) {
    const discr = b * b - 4 * a * c; 

    if ( discr < 0 ) {
      return Infinity;
    } 
    else {
      const sign = b < 0 ? -1 : 1;
      const q = -0.5 * ( b + sign * Math.sqrt( discr ) );
      const x0 = q / a;
      const x1 = c / q;
      return x0 < 0 ? x1 : x0;
    } 
  }
  
</script>
