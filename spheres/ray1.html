<link rel="stylesheet" href="../style.css">

<canvas id="canvas" width="800" height="600"></canvas>

<script type="module">

  // TODO: Settings object, changeable by dat.UI

  const ctx = document.getElementById( 'canvas' ).getContext( '2d' );

  const sphere = {
    pos: { x: 1, y: 1, z: 1 },
    radius: 1
  };

  function getValue( x, y ) {
    // const val = Math.max( 0, Math.sin( 0.02 * ( x + y ) ) ) * 255;

    const cols = ctx.canvas.width;
    const rows = ctx.canvas.height;

    const aspectRatio = cols / rows;
    const FOV = Math.PI * ( 1 / 3 );

    // TODO: How to handle this for non-square views?
    // TODO: This seems distorted at the edges
    const u = ( ( x + 0.5 ) / cols - 0.5 ) * FOV * aspectRatio;
    const v = ( 1 - ( y + 0.5 ) / rows - 0.5 ) * FOV;

    const dist = Math.hypot( Math.sin( u ), Math.sin( v ), 1 );

    const ray = {
      pos: {
        x: 0,
        y: 0,
        z: -4,
      },
      dir: {
        x: Math.sin( u ) / dist, 
        y: Math.sin( v ) / dist, 
        z: 1 / dist,
      },
    }

    const hitTime = intersect( ray, sphere );

    const hitPoint = add( ray.pos, mult( ray.dir, hitTime ) );

    const hitNormal = normalize( sub( hitPoint, sphere.pos ) );

    if ( hitTime < Infinity ) {
      const val = Math.max( 0, dot( hitNormal, ray.dir ) ) * 255;
 
      return ( 255 << 24 ) | ( val << 16 ) | ( val << 8 ) | val;
    }
    else {
      return 0;
    }
  }

  function drawValues( valFunc ) {
    const timeStr = `Drawing values`;
    console.time( timeStr );

    const cols = ctx.canvas.width;
    const rows = ctx.canvas.height;

    const imageData = ctx.getImageData( 0, 0, cols, rows );

    const buf = new ArrayBuffer( imageData.data.length );
    const buf8 = new Uint8ClampedArray( buf );
    const data = new Uint32Array( buf );

    let index = 0;
    for ( var y = 0; y < rows; y ++ ) {
      for ( var x = 0; x < cols; x ++ ) {
        data[ index ++ ] = valFunc( x, y );
      }
    }

    imageData.data.set( buf8 );
    ctx.putImageData( imageData, 0, 0 );

    console.timeEnd( timeStr );
  }

  drawValues( getValue );

  // See https://www.scratchapixel.com/lessons/3d-basic-rendering/minimal-ray-tracer-rendering-simple-shapes/ray-sphere-intersection

  function intersect( ray, sphere ) {

    const L = sub( ray.pos, sphere.pos );

    const a = 1; // dot( ray.dir, ray.dir );  // can be 1 if dir is normalized
    const b = 2 * dot( ray.dir, L );
    const c = dot( L, L ) - sphere.radius * sphere.radius;
    
    const t = solveQuadratic( a, b, c );

    return t;
  }

  // https://mathworld.wolfram.com/QuadraticEquation.html
  function solveQuadratic( a, b, c ) {
    const discr = b * b - 4 * a * c; 

    if ( discr < 0 ) {
      return Infinity;
    } 
    else {
      const sign = b < 0 ? -1 : 1;
      const q = -0.5 * ( b + sign * Math.sqrt( discr ) );
      const x0 = q / a;
      const x1 = c / q;
      return x0 < 0 ? x1 : x0;
    } 
  }

  function dot( a, b ) {
    return a.x * b.x + a.y * b.y + a.z * b.z;
  }

  function normalize( a ) {
    const len = Math.hypot( a.x, a.y, a.z );
    return {
      x: a.x / len,
      y: a.y / len,
      z: a.z / len,
    };
  }

  function add( a, b ) {
    return { 
      x: a.x + b.x,
      y: a.y + b.y,
      z: a.z + b.z,
    }
  }

  function sub( a, b ) {
    return {
      x: a.x - b.x,
      y: a.y - b.y,
      z: a.z - b.z,
    }
  }

  function mult( a, b ) {
    return { 
      x: a.x * b,
      y: a.y * b,
      z: a.z * b,
    }
  }
  
</script>
