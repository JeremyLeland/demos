<link rel="stylesheet" href="../grid.css">
<script type="module">
  import * as THREE from '../lib/three.module.js';
  import { OrbitControls } from '../lib/controls/OrbitControls.js';

  import * as Shaders from './QuadricShaders.js';

  const EllipticParaboloid = [
    1, 0, 0, 0,
    0, 0, 0, 1,
    0, 0, 1, 0,
    0, 0, 0, -1
  ];

  class Shape {
    object;

    Q;
    minBounds;
    maxBounds;

    material;
        
    constructor( json ) {
      this.object = new THREE.Object3D();
      this.object.position.set( json.position.x, json.position.y, json.position.z );
      this.object.rotation.set( json.rotation.x, json.rotation.y, json.rotation.z );
      this.object.scale.set( json.scale.x, json.scale.y, json.scale.z );
      // this.object.updateMatrixWorld();

      this.Q = new THREE.Matrix4().fromArray( json.quadricMatrix );
      this.minBounds = new THREE.Vector3( json.minBounds.x, json.minBounds.y, json.minBounds.z );
      this.maxBounds = new THREE.Vector3( json.maxBounds.x, json.maxBounds.y, json.maxBounds.z );

      this.material = {
        color: new THREE.Vector4( json.material.color.r, json.material.color.g, json.material.color.b, 1 ),
        shininess: json.material.shininess,
      };
    }

    getUniform() {
      this.object.updateMatrixWorld();

      const inverseMatrix = this.object.matrixWorld.clone().invert();
      const normalMatrix = inverseMatrix.clone().transpose();

      // NOTE: Matrices need to be transposed to be used in GLSL
      return {
        Q: this.Q,
        minBounds: this.minBounds,
        maxBounds: this.maxBounds,
        inverseMatrix: inverseMatrix.transpose(),
        normalMatrix: normalMatrix.transpose(),
        material: this.material,
      };
    }
  }

  const json = {
    shapes: [
      {
        quadricMatrix: EllipticParaboloid,
        minBounds: { x: -2, y:  -1, z: -1.5 },
        maxBounds: { x:  2, y: 0.8, z:  1.1 },
        position: { x: 0, y: 0, z: 0 },
        rotation: { x: 0, y: 0, z: 0 },
        scale:    { x: 1, y: 2, z: 1 },
        material: {
          color: { r: 0.25, g: 0.5, b: 0 },
          shininess: 2000,
        },
      },
      {
        quadricMatrix: EllipticParaboloid,
        minBounds: { x: -2, y:  -1, z: -1.5 },
        maxBounds: { x:  2, y: 0.8, z:  1.1 },
        position: { x: 0, y: 1, z: -3 },
        rotation: { x: 0, y: 0, z: 0 },
        scale:    { x: 1, y: 3, z: 1 },
        material: {
          color: { r: 0.5, g: 0.25, b: 0 },
          shininess: 2000,
        },
      },
      {
        quadricMatrix: EllipticParaboloid,
        minBounds: { x: -2, y:  -1, z: -1.5 },
        maxBounds: { x:  2, y: 0.8, z:  1.1 },
        position: { x: 1, y: 0, z: 0 },
        rotation: { x: 0, y: 0, z: 0 },
        scale:    { x: 1, y: 2, z: 1 },
        material: {
          color: { r: 0, g: 0.25, b: 0.5 },
          shininess: 2000,
        },
      },
    ]
  };

  const shapes = json.shapes.map( shapeJson => new Shape( shapeJson ) );

  const scene = new THREE.Scene();
  scene.background = new THREE.Color( 0x111111 );

  const camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 100 );
  camera.position.set( 0, 0, 5 );

  const uniforms = {};

  function updateUniforms() {
    camera.updateMatrixWorld();

    uniforms.camera = { value: { matrix: camera.matrixWorld.clone().transpose() }, };
    uniforms.shapes = { value: shapes.map( shape => shape.getUniform() ) };
    uniforms.light = { 
      value: {
        position: new THREE.Vector4( 1, 1, 5, 1 ),
        color: new THREE.Vector4( 1, 1, 1, 1 ),
      },
    };
    uniforms.material = {
      value: {
        color: new THREE.Vector4( 0.5, 0.25, 0, 1 ),
        shininess: 2000,
      },
    };
  }

  updateUniforms();
  

  scene.add( new THREE.Mesh(
    new THREE.PlaneGeometry( 2, 2 ),
    new THREE.RawShaderMaterial( {
      uniforms: uniforms,
      vertexShader: Shaders.VertScreenPos,
      fragmentShader: /* glsl */ `
        precision highp float;
        precision highp int;

        in vec4 screenPos;
        out vec4 outColor;

        ${ Shaders.QuadricHit }
        ${ Shaders.Lighting }

        struct Camera {
          mat4 matrix;
        };

        struct Shape {
          mat4 Q;
          vec3 minBounds;
          vec3 maxBounds;
          mat4 inverseMatrix;
          mat4 normalMatrix;
          Material material;
        };

        uniform Camera camera;
        uniform Shape shapes[ 3 ];
        uniform Light light;

        struct Hit {
          vec4 hitInfo;
          int shapeIndex;
        };

        Hit getClosestHit( vec4 rayPos, vec4 rayDir ) {
          vec4 closestHit = vec4( 0.0, 0.0, 0.0, -1.0 );
          int closestIndex = -1;

          for ( int i = 0; i < shapes.length(); i ++ ) {

            vec4 C = rayPos * shapes[ i ].inverseMatrix;
            vec4 D = rayDir * shapes[ i ].inverseMatrix;

            vec4 hit = quadricSurfaceHit( shapes[ i ].Q, shapes[ i ].minBounds, shapes[ i ].maxBounds, C, D );
            
            if ( hit.w > 0.01 && ( closestHit.w == -1.0 || hit.w < closestHit.w ) ) {
              closestHit = hit;
              closestIndex = i;
            }
          }

          return Hit( closestHit, closestIndex );
        }
        
        void main() {
          vec4 rayPos = ( vec4( 0.0, 0.0, 0.0, 1.0 ) * camera.matrix );
          vec4 rayDir = ( vec4( normalize( vec3( screenPos.xy, -1.0 ) ), 0.0 ) * camera.matrix );

          Hit hit = getClosestHit( rayPos, rayDir );
          float hitTime = hit.hitInfo.w;

          if ( hitTime > 0.0 ) {
            vec4 hitPos = rayPos + rayDir * hitTime;

            vec4 objNorm = quadricSurfaceNormal( shapes[ hit.shapeIndex ].Q, vec4( hit.hitInfo.xyz, 1.0 ) );
            vec4 N = normalize( objNorm * shapes[ hit.shapeIndex ].normalMatrix );

            // if backside, flip normal
            if ( dot( rayDir, N ) > 0.0 ) {
              N *= -1.0;
            }

            vec4 toLight = light.position - hitPos;
            float lightDist = length( toLight );
            vec4 L = normalize( toLight );
            vec4 V = normalize( rayPos - hitPos );

            Hit lightHit = getClosestHit( hitPos, L );
            float lightTime = lightHit.hitInfo.w;

            if ( lightTime < 0.01 || lightTime > lightDist ) {
              outColor = getLighting( L, V, N, light, shapes[ hit.shapeIndex].material );
            }
          }
          else {
            discard;
          }
        }
      `,
      glslVersion: THREE.GLSL3,
    } )
  ) );

  const renderer = new THREE.WebGLRenderer();
  renderer.setPixelRatio( window.devicePixelRatio );

  function animate( now ) {
    // lights[ 1 ].position.set( Math.cos( now / 1000 ), Math.sin( now / 500 ), 5 );

    // shape.object.rotation.set( now / 4000, now / 3000, now / 10000 );
    shapes[ 0 ].object.rotation.set( now / 4000, now / 1000, 0 );

    render();

    requestAnimationFrame( animate );
  }
  requestAnimationFrame( animate );

  function render() {
    updateUniforms();
    renderer.render( scene, camera );
  }

  document.body.appendChild( renderer.domElement );
  window.onresize = () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();

    renderer.setSize( window.innerWidth, window.innerHeight );
    render();
  }
  window.onresize();

  const controls = new OrbitControls( camera, renderer.domElement );
  controls.target.set( 0, 0, 0 );
  controls.update();
  controls.addEventListener( 'change', render );

</script>
