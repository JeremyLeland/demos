<link rel="stylesheet" href="../grid.css">
<script type="module">
  import * as THREE from '../lib/three.module.js';
  import { OrbitControls } from '../lib/controls/OrbitControls.js';

  import * as Shaders from './QuadricShaders.js';

  const EllipticParaboloid = [
    1, 0, 0, 0,
    0, 0, 0, 1,
    0, 0, 1, 0,
    0, 0, 0, -1
  ];

  class Shape {
    object;

    Q;
    minBounds;
    maxBounds;
        
    constructor( json ) {
      this.object = new THREE.Object3D();
      this.object.position.set( json.position.x, json.position.y, json.position.z );
      this.object.rotation.set( json.rotation.x, json.rotation.y, json.rotation.z );
      this.object.scale.set( json.scale.x, json.scale.y, json.scale.z );
      // this.object.updateMatrixWorld();

      this.Q = new THREE.Matrix4().fromArray( json.quadricMatrix );
      this.minBounds = new THREE.Vector3( json.minBounds.x, json.minBounds.y, json.minBounds.z );
      this.maxBounds = new THREE.Vector3( json.maxBounds.x, json.maxBounds.y, json.maxBounds.z );
    }

    getUniform() {
      this.object.updateMatrixWorld();

      const inverseMatrix = this.object.matrixWorld.clone().invert();
      const normalMatrix = inverseMatrix.clone().transpose();

      // NOTE: Matrices need to be transposed to be used in GLSL
      return {
        Q: this.Q,
        minBounds: this.minBounds,
        maxBounds: this.maxBounds,
        inverseMatrix: inverseMatrix.transpose(),
        normalMatrix: normalMatrix.transpose(),
      };
    }
  }

  const shape = new Shape( {
    quadricMatrix: EllipticParaboloid,
    minBounds: { x: -2, y:  -1, z: -1.5 },
    maxBounds: { x:  2, y: 0.8, z:  1.1 },
    position: { x: 0, y: 0, z: 0 },
    rotation: { x: 0, y: 0, z: 0 },
    scale:    { x: 1, y: 2, z: 1 },
  } );

  const scene = new THREE.Scene();
  scene.background = new THREE.Color( 0x111111 );

  const camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 100 );
  camera.position.set( 0, 0, 5 );

  const uniforms = {};

  function updateUniforms() {
    camera.updateMatrixWorld();

    uniforms.camera = { value: { matrix: camera.matrixWorld.clone().transpose() }, };
    uniforms.shape = { value: shape.getUniform() };
    uniforms.light = { 
      value: {
        position: new THREE.Vector4( 1, 1, 5, 1 ),
        color: new THREE.Vector4( 1, 1, 1, 1 ),
      },
    };
    uniforms.material = {
      value: {
        color: new THREE.Vector4( 0.5, 0.25, 0, 1 ),
        shininess: 2000,
      },
    };
  }

  updateUniforms();
  

  scene.add( new THREE.Mesh(
    new THREE.PlaneGeometry( 2, 2 ),
    new THREE.RawShaderMaterial( {
      uniforms: uniforms,
      vertexShader: Shaders.VertScreenPos,
      fragmentShader: /* glsl */ `
        precision highp float;
        precision highp int;

        in vec4 screenPos;
        out vec4 outColor;

        ${ Shaders.QuadricHit }
        ${ Shaders.Lighting }

        struct Camera {
          mat4 matrix;
        };

        uniform Camera camera;
        uniform Shape shape;
        uniform Light light;
        uniform Material material;
        
        void main() {
          vec4 rayPos = ( vec4( 0.0, 0.0, 0.0, 1.0 ) * camera.matrix );
          vec4 rayDir = ( vec4( normalize( vec3( screenPos.xy, -1.0 ) ), 0.0 ) * camera.matrix );

          Hit hit = quadricHit( shape, rayPos, rayDir );

          if ( hit.time > 0.0 ) {
            vec4 toLight = light.position - hit.position;
            float lightDist = length( toLight );
            vec4 L = normalize( toLight );
            vec4 V = normalize( rayPos - hit.position );

            Hit lightHit = quadricHit( shape, hit.position, L );

            if ( lightHit.time < 0.01 || lightHit.time > lightDist ) {
              outColor = getLighting( L, V, hit.normal, light, material );
            }
          }
          else {
            discard;
          }
        }
      `,
      glslVersion: THREE.GLSL3,
    } )
  ) );

  const renderer = new THREE.WebGLRenderer();
  renderer.setPixelRatio( window.devicePixelRatio );

  function animate( now ) {
    // lights[ 1 ].position.set( Math.cos( now / 1000 ), Math.sin( now / 500 ), 5 );

    // shape.object.rotation.set( now / 4000, now / 3000, now / 10000 );
    shape.object.rotation.set( now / 4000, 0, 0 );

    render();

    requestAnimationFrame( animate );
  }
  requestAnimationFrame( animate );

  function render() {
    updateUniforms();
    renderer.render( scene, camera );
  }

  document.body.appendChild( renderer.domElement );
  window.onresize = () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();

    renderer.setSize( window.innerWidth, window.innerHeight );
    render();
  }
  window.onresize();

  const controls = new OrbitControls( camera, renderer.domElement );
  controls.target.set( 0, 0, 0 );
  controls.update();
  controls.addEventListener( 'change', render );

</script>
