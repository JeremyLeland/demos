<!-- Confusing: https://github.com/amirhosseinh77/Flocking-Multi-Agent -->
<!-- Clearer code: https://docs.ros.org/en/kinetic/api/olfati_saber_flocking/html/olfati__saber__flocking_8cpp_source.html -->
<!-- Better documentation: https://github.com/zhubiii/mj-SaberFlocking/blob/main/src/algo1.py -->

<title>Flocking Multi Agent port</title>
<link rel="stylesheet" href="../grid.css">

<script type="module">
  import { Canvas } from '../src/common/Canvas.js';

  const SIZE = 100;
  const canvas = new Canvas();

  // TODO: x,y dx,dy ddx,ddy?
  const agents = Array.from( Array( 50 ), _ => [ Math.random() * 100, Math.random() * 100 ] ).map( pos => ( { 
    p: pos, q: [ 0, 0 ], u: [ 0, 0 ],
    size: Math.random() * 2 + 1,
  } ) );
  //[
  //  [ 10, 10 ], [ 15, 15 ], [ 15, 10 ], [ 10, 15 ],
  //]

  let targetX = 50, targetY = 50;
  
  const RANGE = 3;       // radius of FOV
  const DISTANCE = 2;    // distance between agents


  function sigma_1( z ) {
    return z / Math.sqrt( 1 + z * z );    // TODO: Should epsilon go here as well?
  }

  const EPSILON = 0.1;    // how smooth the function is

  function sigma_norm( v ) {
    return ( Math.sqrt( 1 + EPSILON * ( v[ 0 ] * v[ 0 ] + v[ 1 ] * v[ 1 ] ) ) - 1 ) / EPSILON;
  }

  function sigma_grad( v ) {
    return v.map( z => z / Math.sqrt( 1 + EPSILON * ( v[ 0 ] * v[ 0 ] + v[ 1 ] * v[ 1 ] ) ) );
  }

  const A = 5, B = 5;  // 0<A<=B 
  const C = Math.abs( A - B ) / Math.sqrt( 4 * A * B );
  function phi( z ) {
    return 0.5 * ( ( A + B ) * sigma_1( z + C ) + A - B );
  }

  const H = 0.2;
  function rho( z ) {
    if ( z < H )  return 1;
    if ( z > 1 )  return 0;
    return 0.5 * ( 1 + Math.cos( Math.PI * ( z - H ) / ( 1 - H ) ) );
  }

  // Alpha: Movement relative to neighbors?
  // Gamma: movement toward target?

  const C1_alpha = 4;
  const C2_alpha = 2 * Math.sqrt( C1_alpha );
  const C1_gamma = 4;
  const C2_gamma = 0.2 * Math.sqrt( C1_gamma );

  canvas.update = ( dt ) => {

    agents.forEach( agent => {

      const neighbors = agents.filter( other => Math.hypot( other.p[ 0 ] - agent.p[ 0 ], other.p[ 1 ] - agent.p[ 1 ] ) <= other.size + agent.size + RANGE );
      
      let sum = [ 0, 0 ];

      neighbors.forEach( neighbor => {
        const diff = [ neighbor.p[ 0 ] - agent.p[ 0 ], neighbor.p[ 1 ] - agent.p[ 1 ] ];
        const n_ij = sigma_grad( diff );
        const sigNormDiff = sigma_norm( diff );
        
        const r_alpha = sigma_norm( [ RANGE + neighbor.size + agent.size, 0 ] );
        const d_alpha = sigma_norm( [ DISTANCE + neighbor.size + agent.size, 0 ] );
        
        const bump = rho( sigNormDiff / r_alpha );
        const phiVal = phi( sigNormDiff - d_alpha );

        sum[ 0 ] += bump * ( phiVal * n_ij[ 0 ] + neighbor.q[ 0 ] - agent.q[ 0 ] );
        sum[ 1 ] += bump * ( phiVal * n_ij[ 1 ] + neighbor.q[ 1 ] - agent.q[ 1 ] );
      } );
      
      agent.u[ 0 ] = C2_alpha * sum[ 0 ] - C1_gamma * sigma_1( agent.p[ 0 ] - targetX ) - C2_gamma * agent.q[ 0 ];
      agent.u[ 1 ] = C2_alpha * sum[ 1 ] - C1_gamma * sigma_1( agent.p[ 1 ] - targetY ) - C2_gamma * agent.q[ 1 ];
    } );

    const time = dt / 200;     // code needs to run in small time chunks, it seems

    agents.forEach( agent => {
      agent.q[ 0 ] += agent.u[ 0 ] * time;
      agent.q[ 1 ] += agent.u[ 1 ] * time;

      // NOTE: This didn't have as noticeable an effect as I thought
      //       Maybe speed is already maintained by the C#_gamma variables above?
      // const speed = Math.hypot( agent.q[ 0 ], agent.q[ 1 ] );
      // const MAX_SPEED = 100;
      // if ( speed > MAX_SPEED ) {
      //   const slowRatio = MAX_SPEED / speed;
      //   agent.q[ 0 ] *= slowRatio;
      //   agent.q[ 1 ] *= slowRatio;
      // }

      agent.p[ 0 ] += agent.q[ 0 ] * time;
      agent.p[ 1 ] += agent.q[ 1 ] * time;
    } );

  };

  canvas.draw = ( ctx ) => {
    ctx.scale( 1 / SIZE, 1 / SIZE );

    ctx.fillStyle = '#aaaa';
    agents.forEach( agent => {
      ctx.beginPath();
      ctx.arc( agent.p[ 0 ], agent.p[ 1 ], agent.size, 0, Math.PI * 2 );
      ctx.fill();
    } );
  };

  canvas.start();

  let mouseDown = false;

  document.addEventListener( 'pointerdown', ( e ) => doMouse( e ) );
  document.addEventListener( 'pointerup', _ => mouseDown = false );
  document.addEventListener( 'pointermove', ( e ) => {
    if ( mouseDown ) {
      doMouse( e );
    }
  } );

  function doMouse( e ) {
    mouseDown = true;

    targetX = SIZE * e.offsetX / canvas.scale;
    targetY = SIZE * e.offsetY / canvas.scale;
  }

</script>