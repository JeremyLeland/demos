<title>Avoid Cones</title>
<link rel="stylesheet" href="../grid.css">

<script type="module">
  import { AnimatedCanvas } from './AnimatedCanvas.js';
  import { EntitySimulator } from './EntitySimulator.js';
  import { ValuesPanel } from './ValuesPanel.js';
  import { Entity } from './Entity.js';
  import { AvoidCones } from './AvoidCones.js';

  
  function shipPath() {
    const path = new Path2D();
    path.moveTo( 1, 0 );
    path.arc( 0, 0, 1, 2.2, -2.2 );
    path.closePath();
    return path;
  }

  function rockPath() {
    const path = new Path2D();
    path.arc( 0, 0, 1, 0, Math.PI * 2 );
    return path;
  }

  class Ship extends Entity {
    size = 16;
    // color = 'green';
    drawPath = shipPath();
    turnSpeed = 0.008;
    moveSpeed = 0.02;

    update( dt ) {
      if ( dt > 0 ) {

        const goalTurn = deltaAngle( this.angle, this.goalAngle );
        const turn = Math.min( Math.abs( goalTurn ), this.turnSpeed * dt );
        this.angle += Math.sign( goalTurn ) * turn;

        // this.angle = this.goalAngle;  // TODO: turn toward (not instant)
        
        this.dx = Math.cos( this.angle ) * this.moveSpeed * dt;
        this.dy = Math.sin( this.angle ) * this.moveSpeed * dt;
        
        super.update( dt );
      }
    }
  }

  class Rock extends Entity {
    size = 30;
    color = 'brown';
    drawPath = rockPath();
  }

  const entities = [
    // new Ship( { x: 200, y: 200, angle:  1, color: 'red' } ),
    new Ship( { x: 250, y: 250, angle:  0, color: 'orange' } ),
    // new Ship( { x: 200, y: 300, angle: -1, color: 'yellow' } ),
    // new Ship( { x: 100, y: 200, angle:  1, color: 'salmon' } ),
    // new Ship( { x: 150, y: 250, angle:  0, color: 'maroon' } ),
    // new Ship( { x: 100, y: 300, angle: -1, color: 'pink' } ),
    // new Rock( { x: 400, y: 250 } ),
    // new Rock( { x: 400, y: 320 } ),
  ];

  const Constants = {
    TargetWeight: 0.1,
    AlignWeight: 10,
    AvoidWeight: 1,
    MaxSpeed: 0.1,
    UIScale: 100,
  };

  new ValuesPanel( Constants ).valueChanged = refresh;
  new EntitySimulator( entities ).onInput = refresh;

  const canvas = new AnimatedCanvas();

  let target = { x: 500, y: 300 };

  canvas.update = ( dt ) => {
    entities.forEach( entity => {

      entity.avoidCones = new AvoidCones();
      entity.avoidCones.addCone( { left: -1, right: 1 } );
      entity.avoidCones.addCone( { left: -1, right: 2 } );

      entities.filter( e => e != entity ).forEach( other => {
        const cx = other.x - entity.x;
        const cy = other.y - entity.y;
        const dist = Math.hypot( cx, cy );
        const angle = Math.atan2( cy, cx );

        
        const r = entity.size + other.size + 20;
        const h = Math.hypot( cx, cy );
        const spread = Math.asin( Math.min( 1, r / h ) );   // min() prevents floating errors when we get really close

      } );

      const targetAngle = Math.atan2( target.y - entity.y, target.x - entity.x );

      entity.goalAngle = targetAngle;
    } );

    entities.forEach( entity => entity.update( dt ) );
  };
  
  canvas.draw = ( ctx ) => {
    entities.forEach( entity => entity.draw( ctx ) );

    // Avoid cones
    entities.forEach( entity => {
      ctx.save();
      ctx.translate( entity.x, entity.y );

      entity.avoidCones?.draw( ctx );

      ctx.restore();
    } );
  };

  function fixAngle( a ) {
    return a > Math.PI ? a - Math.PI * 2 : a < -Math.PI ? a + Math.PI * 2 : a;
  }

  function deltaAngle( a, b ) {
    return fixAngle( b - a );
  }
 
  // anim.start();

  function refresh() {
    canvas.update( 0 );
    canvas.redraw();
  }
  
  refresh();

  document.addEventListener( 'keydown', ( e ) => {
    canvas.update( 10 );
    canvas.redraw();
  } );
  
  document.addEventListener( 'mousemove', ( e ) => {
    target = { x: e.clientX, y: e.clientY };
  } );
  
</script>