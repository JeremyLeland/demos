<title>Cell Test</title>
<link rel="stylesheet" href="../../style.css">

<body>
  <canvas id="canvas" width="800px" height="800px"></canvas>
</body>

<script type="module">
  import { Cell } from '../../src/Cell.js';
  import { Curve } from '../../src/Curve.js';

  const cols = 2, rows = 3, size = 64, offset = 32;

  // function getCellHexGrid( cols, rows, size = 64, offset = 32 ) {
    const cellPoints = Array.from(
      Array( cols * 2 + 1 ), ( _, col ) => Array.from(
        Array( rows + 2 ), ( _, row ) => ( {
          x: ( col + ( ( col + ( ( row + 1 ) % 2 ) ) % 2 ) * 0.3 ) * size,// + ( Math.random() - 0.5 ) * offset,
          y: row * 0.6 * size,// + ( Math.random() - 0.5 ) * offset,
        } )
      )
    );

    const cellGrid = Array.from(
      Array( cols ), ( _, col ) => Array.from(
        Array( rows ), ( _, row ) => {
          const c = col * 2 + ( row % 2 ), r = row;
          return new Cell( [
            cellPoints[ c ][ r ],
            cellPoints[ c ][ r + 1 ],
            cellPoints[ c ][ r + 2 ],
            cellPoints[ c + 1 ][ r + 2 ],
            cellPoints[ c + 1 ][ r + 1 ],
            cellPoints[ c + 1 ][ r ],
          ] );
        }
      )
    );

    for ( let row = 0; row < rows; row ++ ) {
      for ( let col = 0; col < cols; col ++ ) {
        const cell = cellGrid[ col ][ row ];

        // if ( col > 0 )  cell.edges[ 0 ].neighbor = cellGrid[ col - 1 ][ row ];
        if ( row < rows - 2 )  cell.edges[ 2 ].neighbor = cellGrid[ col ][ row + 2 ];
        // if ( col < cols - 1 )  cell.edges[ 2 ].neighbor = cellGrid[ col + 1 ][ row ];
        if ( row > 1 )  cell.edges[ 5 ].neighbor = cellGrid[ col ][ row - 2 ];
      }
    }

  //   return cellGrid;
  // }

  // TODO: Make a hex grid instead of rectangle grid, just for kicks

  // function getHexRooms( cols, rows ) {
  //   const roomHex = Array( cols ).fill().map( x => Array( rows ).fill() );
  //   const rooms = [];

  //   for ( let row = 0; row < roomHex[ 0 ].length; row ++ ) {
  //     for ( let col = 0; col < roomHex.length; col ++ ) {
  //       const room = new Room( ( col + ( row % 2 == 0 ? 1 : 0.5 ) ) * SIZE, ( row + 0.5 ) * SIZE );
  //       roomHex[ col ][ row ] = room;
  //       rooms.push( room );

  //       // TODO: Make sure links are added in clockwise order (like for grid above)

  //       if ( col > 0 ) {
  //         const left = roomHex[ col - 1 ][ row ];
  //         room.neighbors.push( left );
  //         left.neighbors.push( room );
  //       }
  //       if ( row > 0 )  {
  //         const leftCol = col - ( row % 2 );
  //         const rightCol = leftCol + 1;

  //         if ( leftCol >= 0 ) {
  //           const topLeft = roomHex[ leftCol ][ row - 1 ];
  //           room.neighbors.push( topLeft );
  //           topLeft.neighbors.push( room );
  //         }
  //         if ( rightCol < roomHex.length ) {
  //           const topRight = roomHex[ rightCol ][ row - 1 ];
  //           room.neighbors.push( topRight );
  //           topRight.neighbors.push( room );
  //         }
  //       }
  //     }
  //   }

  //   return rooms;
  // }

  // const cellGrid = getCellHexGrid( 2, 2 );


  const ctx = document.getElementById( 'canvas' ).getContext( '2d' );
  ctx.translate( 32, 32 );

  for ( let row = 0; row < cellGrid[ 0 ].length; row ++ ) {
    for ( let col = 0; col < cellGrid.length; col ++ ) {
      cellGrid[ col ][ row ].draw( ctx );
    }
  }

  ctx.fillStyle = 'red';
  for ( let row = 0; row < cellPoints[ 0 ].length; row ++ ) {
    for ( let col = 0; col < cellPoints.length; col ++ ) {
      const point = cellPoints[ col ][ row ];
      ctx.fillRect( point.x - 1, point.y - 1, 2, 2 );
    }
  }

  // ctx.strokeStyle = 'yellow';

  // const points = [];

  // let edge = cellGrid[ 0 ][ 1 ].edges[ 0 ];
  // const visited = new Set();

  // while ( !visited.has( edge ) ) {
  //   visited.add( edge );

  //   // points.push( ...edge.getOffsetPoints( 10 ) );
  //   points.push( edge.start );

  //   edge = edge.next;
  // }

  // ctx.beginPath();
  // points.forEach( p => ctx.lineTo( p.x, p.y ) );
  // ctx.closePath();
  // ctx.stroke();

  // const curves = Curve.getLoopThroughPoints( points );
  // curves.forEach( curve => curve.draw( ctx ) );

</script>
