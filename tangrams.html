<link rel='stylesheet' href='./style.css'>

<style>
  svg {
    background-color: gray;
    width: 100%;
    height: 100%;
    stroke: black;
    stroke-width: 0.04;
  }
  .hexagon    { fill: yellow; }
  .trapezoid  { fill: red; }
  .diamond    { fill: blue; }
  .triangle   { fill: green; }
  .square     { fill: orange; }
  .thin       { fill: tan; }
</style>

<body>
  <svg id='svg' viewBox="-6 -6 12 12"></svg>
</body>

<script>
  const svg = document.getElementById( 'svg' );

  function fixAngle( a ) {
    return a > Math.PI ? a - Math.PI * 2 : a < -Math.PI ? a + Math.PI * 2 : a;
  }

  function deltaAngle( a, b ) {
    return fixAngle( b - a );
  }

  class Edge {
    x1;
    y1;
    x2;
    y2;
    link;
    owner;

    constructor( info ) {
      Object.assign( this, info );
    }

    getTransformed( angle = this.owner.angle ) {
      const cosX = Math.cos( angle );
      const sinX = Math.sin( angle );
      const cosY = Math.cos( angle + Math.PI / 2 );
      const sinY = Math.sin( angle + Math.PI / 2 );

      return {
        x1: this.owner.x + cosX * this.x1 + cosY * this.y1,
        y1: this.owner.y + sinX * this.x1 + sinY * this.y1,
        x2: this.owner.x + cosX * this.x2 + cosY * this.y2,
        y2: this.owner.y + sinX * this.x2 + sinY * this.y2,
      };
    }

    getTransformToAlignWith( other ) {
      const seg1 = this.getTransformed();
      const seg2 = other.getTransformed();

      // Since edges are running opposite directions, we will compare x1,y1 to x2,y2 and vice versa
      const dAngle = deltaAngle(
        Math.atan2( seg2.y1 - seg2.y2, seg2.x1 - seg2.x2 ),
        Math.atan2( seg1.y2 - seg1.y1, seg1.x2 - seg1.x1 ),
      );

      const seg2rotated = other.getTransformed( other.owner.angle + dAngle );
      
      return { 
        dx: seg1.x1 - seg2rotated.x2,
        dy: seg1.y1 - seg2rotated.y2, 
        dAngle: dAngle
      };
    }
  }
  
  class Block {
    type;
    x = 0;
    y = 0;
    angle = 0;

    edges = [];
    #svg;

    constructor( info ) {
      Object.assign( this, info );

      const blockInfo = BlockInfo[ this.type ];

      const size = 100;
      const points = blockInfo.points;
      for ( let i = 0; i < points.length; i ++ ) {
        const current = points[ i ], next = points[ ( i + 1 ) % points.length ];

        this.edges.push( new Edge( { 
          x1: current[ 0 ], 
          y1: current[ 1 ],
          x2: next[ 0 ],
          y2: next[ 1 ],
          owner: this, 
        } ) );
      }

      this.#svg = document.createElementNS( 'http://www.w3.org/2000/svg', 'path' );
      this.#svg.setAttribute( 'class', this.type );
      this.#svg.setAttribute( 'd', `M ${ points.join( ' L ' ) } Z` );
      svg.appendChild( this.#svg );
    }

    updateSVG() {
      this.#svg.style.transform = `translate( ${ this.x }px,${ this.y }px ) rotate( ${ this.angle }rad )`;
    }
  }

  const HEIGHT = Math.sqrt( 3 ) / 2;

  const BlockInfo = {
    hexagon: {
      points: [ 
        [ -1, 0 ], [ -1/2, -HEIGHT ], [ 1/2, -HEIGHT ], [ 1, 0 ], [ 1/2, HEIGHT ], [ -1/2, HEIGHT ]
      ],
    },
    trapezoid: {
      points: [ [ -1, HEIGHT / 2 ], [ -1/2, -HEIGHT / 2 ], [ 1/2, -HEIGHT / 2 ], [ 1, HEIGHT / 2 ] ],
    },
    diamond: {
      points: [ [ 0, -HEIGHT ], [ 1/2, 0 ], [ 0, HEIGHT ], [ -1/2, 0 ] ],
    },
    triangle: {
      points: [ [ 0, -2 * HEIGHT / 3 ], [ 1/2, HEIGHT / 3 ], [ -1/2, HEIGHT / 3 ] ],
    },
    square: {
      points: [ [ -1/2, -1/2 ], [ 1/2, -1/2 ], [ 1/2, 1/2 ], [ -1/2, 1/2 ] ],
    },
    thin: {
      points: [ [ 0, -Math.cos( Math.PI / 12 ) ], [ 1/4, 0 ], [ 0, Math.cos( Math.PI / 12 ) ], [ -1/4, 0 ] ],
    },
  }

  const level = [
    { type: 'hexagon', x: 0, y: 0, angle: 0 },

    { type: 'hexagon', x: -2, y: 0, angle: 0 },
    { type: 'hexagon', x:  2, y: 0, angle: 0 },

    { type: 'triangle', x: -3, y: HEIGHT * -2/3, angle: Math.PI },
    { type: 'triangle', x:  3, y: HEIGHT * -2/3, angle: Math.PI },
    { type: 'triangle', x: -3, y: HEIGHT *  2/3, angle: 0 },
    { type: 'triangle', x:  3, y: HEIGHT *  2/3, angle: 0 },

    { type: 'diamond', x: -1, y: -HEIGHT, angle: 0 },
    { type: 'diamond', x:  1, y: -HEIGHT, angle: 0 },
    { type: 'diamond', x: -1, y:  HEIGHT, angle: 0 },
    { type: 'diamond', x:  1, y:  HEIGHT, angle: 0 },

    { type: 'diamond', x: -3.5, y: 0, angle: 0 },
    { type: 'diamond', x:  3.5, y: 0, angle: 0 },

    {
      type: 'square', 
      x: 3.5 + Math.cos( Math.PI * -1/6 ) * ( HEIGHT/3 + 1/2 ), 
      y: HEIGHT * -1/3 + Math.sin( Math.PI * -1/6 ) * ( HEIGHT/3 + 1/2 ), 
      angle: Math.PI * -1/6
    },
    {
      type: 'square', 
      x: 3.5 + Math.cos( Math.PI / 6 ) * ( HEIGHT/3 + 1/2 ), 
      y: HEIGHT * 1/3 + Math.sin( Math.PI / 6 ) * ( HEIGHT/3 + 1/2 ), 
      angle: Math.PI / 6
    },
    { type: 'triangle', x: 4 + HEIGHT * 2/3, y: 0, angle: Math.PI / 6 },

    { type: 'trapezoid', x: 0, y: HEIGHT * -3/2, angle: Math.PI },
    { type: 'trapezoid', x: 0, y: HEIGHT *  3/2, angle: 0 },

    {
      type: 'thin',
      x: 2,// + Math.cos( Math.PI / 12 ) * ( HEIGHT/3 ), 
      y: HEIGHT + HEIGHT,// + Math.sin( Math.PI / 12 ) * ( HEIGHT/3 ),
      angle: 0//Math.PI / 12
    },



    { type: 'triangle', x: 0, y: 4, angle: 0 },

    { type: 'square', x: 0, y: 4 + HEIGHT/3 + 1/2, angle: 0 },
    { 
      type: 'square', 
      x: 0 + Math.cos( -Math.PI / 6 ) * ( HEIGHT/3 + 1/2 ), 
      y: 4 + Math.sin( -Math.PI / 6 ) * ( HEIGHT/3 + 1/2 ), 
      angle: -Math.PI / 6 
    },
    { 
      type: 'square', 
      x: 0 + Math.cos( -5 * Math.PI / 6 ) * ( HEIGHT/3 + 1/2 ), 
      y: 4 + Math.sin( -5 * Math.PI / 6 ) * ( HEIGHT/3 + 1/2 ), 
      angle: -5 * Math.PI / 6 
    },

    { type: 'triangle', x: 4, y: 4, angle: 0 },
    { type: 'square', x: 5.5, y: 4, angle: 0 },
  ];

  const blocks = [];

  level.forEach( block => blocks.push( new Block( block ) ) );

  function align( block1, edge1, block2, edge2 ) {
    const transform = block1.edges[ edge1 ].getTransformToAlignWith( block2.edges[ edge2 ] );
    block2.x += transform.dx;
    block2.y += transform.dy;
    block2.angle += transform.dAngle;
  }

  align( blocks[ 10 ], 1, blocks[ 18 ], 3 );
  align( blocks[ 23 ], 0, blocks[ 24 ], 3 );


  blocks.forEach( block => block.updateSVG() );

  
  // For later, if we ever try to save level state in URL
  const levelAscii = JSON.stringify( level );
  const levelBase64 = btoa( levelAscii );

  console.log( levelBase64 );


</script>