<link rel='stylesheet' href='./style.css'>

<style>
  svg {
    background-color: gray;
    width: 100%;
    height: 100%;
    stroke: black;
    stroke-width: 0.04;
  }
</style>

<body>
  <svg viewBox="-6 -6 12 12">
    <g id="blocks"></g>
    <path id="nearest"></path>
  </svg>
</body>

<script>
  const TRI_HEIGHT = Math.sqrt( 3 ) / 2;
  const THIN_WIDTH = Math.cos( Math.PI / 12 );

  const BlockInfo = {
    hexagon: {
      points: [ 
        [ -1, 0 ], [ -1/2, -TRI_HEIGHT ], [ 1/2, -TRI_HEIGHT ], [ 1, 0 ], [ 1/2, TRI_HEIGHT ], [ -1/2, TRI_HEIGHT ]
      ],
      color: 'yellow',
    },
    // TODO: Extra point for long edge of trapezoid (so that all edges have length 1)?
    //       Then solution could be all the outer edges (of length 1)
    trapezoid: {
      points: [ [ -1, TRI_HEIGHT / 2 ], [ -1/2, -TRI_HEIGHT / 2 ], [ 1/2, -TRI_HEIGHT / 2 ], [ 1, TRI_HEIGHT / 2 ] ],
      color: 'red',
    },
    diamond: {
      points: [ [ 0, -TRI_HEIGHT ], [ 1/2, 0 ], [ 0, TRI_HEIGHT ], [ -1/2, 0 ] ],
      color: 'blue',
    },
    triangle: {
      points: [ [ 0, -2 * TRI_HEIGHT / 3 ], [ 1/2, TRI_HEIGHT / 3 ], [ -1/2, TRI_HEIGHT / 3 ] ],
      color: 'green',
    },
    square: {
      points: [ [ -1/2, -1/2 ], [ 1/2, -1/2 ], [ 1/2, 1/2 ], [ -1/2, 1/2 ] ],
      color: 'orange',
    },
    thin: {
      points: [ [ 0, -THIN_WIDTH ], [ 1/4, 0 ], [ 0, THIN_WIDTH ], [ -1/4, 0 ] ],
      color: 'tan',
    },
  };

  function prepareCSS() {
    const styleSheet = document.styleSheets[ 1 ];

    for ( const type in BlockInfo ) {
      const info = BlockInfo[ type ];
      styleSheet.insertRule( `.${ type } {
        d: path( "M ${ info.points.join( ' L ' ) } Z" );
        fill: ${ info.color };
      }` );
    }
  }
  prepareCSS();

  const ALIGN_DELTA = 0.001;

  class Edge {
    x1;
    y1;
    x2;
    y2;
    owner;

    constructor( info ) {
      Object.assign( this, info );
    }

    distanceFrom( other ) {
      const a = this.getTransformed();
      const b = other.getTransformed();

      const rx = b.x1 - a.x1;
      const ry = b.y1 - a.y1;
      const ux = a.x2 - a.x1;
      const uy = a.y2 - a.y1;
      const vx = b.x2 - b.x1;
      const vy = b.y2 - b.y1;

      const ru = rx * ux + ry * uy;
      const rv = rx * vx + ry * vy;
      const uu = ux * ux + uy * uy;
      const uv = ux * vx + uy * vy;
      const vv = vx * vx + vy * vy;

      const det = uu * vv - uv * uv;
      let s, t;

      if ( det < 1e-6 * uu * vv ) {
        s = Math.max( 0, Math.min( ru / uu, 1 ) );
        t = 0;
      }
      else {
        s = Math.max( 0, Math.min( ( ru * vv - rv * uv ) / det, 1 ) );
        t = Math.max( 0, Math.min( ( ru * uv - rv * uu ) / det, 1 ) );
      }

      const S = Math.max( 0, Math.min( ( t * uv + ru ) / uu, 1 ) );
      const T = Math.max( 0, Math.min( ( s * uv - rv ) / vv, 1 ) );

      const Ax = a.x1 + S * ux;
      const Ay = a.y1 + S * uy;
      const Bx = b.x1 + T * vx;
      const By = b.y1 + T * vy;

      return {
        A: this,
        Ax: Ax,
        Ay: Ay,
        B: other,
        Bx: Bx,
        By: By, 
        dist: Math.hypot( Bx - Ax, By - Ay ),
      }
    }

    getTransformed( angle = this.owner.angle ) {
      const cosX = Math.cos( angle );
      const sinX = Math.sin( angle );
      const cosY = Math.cos( angle + Math.PI / 2 );
      const sinY = Math.sin( angle + Math.PI / 2 );

      return {
        x1: this.owner.x + cosX * this.x1 + cosY * this.y1,
        y1: this.owner.y + sinX * this.x1 + sinY * this.y1,
        x2: this.owner.x + cosX * this.x2 + cosY * this.y2,
        y2: this.owner.y + sinX * this.x2 + sinY * this.y2,
      };
    }

    getTransformToAlignWith( other ) {
      const seg1 = this.getTransformed();
      const seg2 = other.getTransformed();

      // Since edges are running opposite directions, we will compare x1,y1 to x2,y2 and vice versa
      const dAngle = deltaAngle(
        Math.atan2( seg1.y2 - seg1.y1, seg1.x2 - seg1.x1 ),
        Math.atan2( seg2.y1 - seg2.y2, seg2.x1 - seg2.x2 ),
      );

      const seg1rotated = this.getTransformed( this.owner.angle + dAngle );
      
      return {
        dx: seg2.x2 - seg1rotated.x1,
        dy: seg2.y2 - seg1rotated.y1, 
        dAngle: dAngle
      };
    }
  }
  
  class Block {
    type;
    x = 0;
    y = 0;
    angle = 0;

    edges = [];
    #svg;

    constructor( info ) {
      Object.assign( this, info );

      const blockInfo = BlockInfo[ this.type ];

      const size = 100;
      const points = blockInfo.points;
      for ( let i = 0; i < points.length; i ++ ) {
        const current = points[ i ], next = points[ ( i + 1 ) % points.length ];

        this.edges.push( new Edge( { 
          x1: current[ 0 ], 
          y1: current[ 1 ],
          x2: next[ 0 ],
          y2: next[ 1 ],
          owner: this, 
        } ) );
      }

      this.#svg = document.createElementNS( 'http://www.w3.org/2000/svg', 'path' );
      this.#svg.setAttribute( 'class', this.type );
      
      this.#svg.addEventListener( 'wheel', wheel );
      this.#svg.addEventListener( 'mousedown', inputStart );
      this.#svg.addEventListener( 'touchstart', inputStart );

      this.#svg.parent = this;
      blocksSVG.appendChild( this.#svg );
    }

    alignEdgeToOtherEdge( edgeIndex, otherEdge ) {
      const transform = this.edges[ edgeIndex ].getTransformToAlignWith( otherEdge );
      this.x += transform.dx;
      this.y += transform.dy;
      this.angle += transform.dAngle;
    }

    updateSVG() {
      this.#svg.style.transform = `translate( ${ this.x }px,${ this.y }px ) rotate( ${ this.angle }rad )`;
    }
  }


  const blocks = [];

  const blocksSVG = document.getElementById( 'blocks' );
  const nearestSVG = document.getElementById( 'nearest' );

  const level = [
    { type: 'hexagon', x: -4, y: 0, angle: 0 },
    { type: 'trapezoid', x: -2, y: 0, angle: 0 },
    { type: 'diamond', x: 0, y: 0, angle: 0 },
    { type: 'triangle', x: 2, y: 0, angle: 0 },
    { type: 'square', x: 4, y: 0, angle: 0 },
    { type: 'thin', x: 5, y: 0, angle: 0 },
  ]

  level.forEach( block => blocks.push( new Block( block ) ) );

  // align( blocks[ 0 ], 0, blocks[ 1 ], 1 );
  // align( blocks[ 2 ], 0, blocks[ 1 ], 2 );
  // align( blocks[ 3 ], 0, blocks[ 2 ], 3 );
  // align( blocks[ 4 ], 0, blocks[ 0 ], 3 );
  // align( blocks[ 5 ], 1, blocks[ 4 ], 3 );


  blocks.forEach( block => block.updateSVG() );

  
  // // For later, if we ever try to save level state in URL
  // const levelAscii = JSON.stringify( level );
  // const levelBase64 = btoa( levelAscii );

  // console.log( levelBase64 );

  // 
  // Input
  //
  document.addEventListener( 'mousemove', inputMove );
  document.addEventListener( 'touchmove', inputMove );
  document.addEventListener( 'mouseup', inputStop );
  document.addEventListener( 'touchend', inputStop );

  let activeBlock, lastX, lastY;
  function wheel( e ) {
    const block = activeBlock ?? e.currentTarget.parent;

    block.angle -= ( e.wheelDelta / 120 ) * ( Math.PI / 12 );
    block.updateSVG();

  }

  function inputStart( e ) {
    activeBlock = e.currentTarget.parent;

    const pos = e.touches?.[ 0 ] ?? e;
    lastX = pos.pageX;
    lastY = pos.pageY;
  }

  function inputMove( e ) {
    if ( activeBlock ) {
      const pos = e.touches?.[ 0 ] ?? e;
      const ratio = 10 / Math.min( window.innerWidth, window.innerHeight );
      const dx = ( pos.pageX - lastX ) * ratio;
      const dy = ( pos.pageY - lastY ) * ratio;
      lastX = pos.pageX;
      lastY = pos.pageY;

      activeBlock.x += dx;
      activeBlock.y += dy;

      // TODO: Combine with below
      const edges = [];
      blocks.filter( b => b != activeBlock ).forEach( b => edges.push( ...b.edges ) );

      const edgeDists = edges.map( e => activeBlock.edges[ 0 ].distanceFrom( e ) );

      nearestSVG.setAttribute( 'd', edgeDists.map( e => `M ${ e.Ax },${ e.Ay } L ${ e.Bx },${ e.By } ` ).join() );

      edgeDists.sort( ( a, b ) => a.dist - b.dist );

      if ( edgeDists[ 0 ].dist < 0.1 ) {
        activeBlock.alignEdgeToOtherEdge( 0, edgeDists[ 0 ].B );
      }

      activeBlock.updateSVG();
    }
  }

  function inputStop( e ) {
    activeBlock = null;
  }


  function fixAngle( a ) {
    return a > Math.PI ? a - Math.PI * 2 : a < -Math.PI ? a + Math.PI * 2 : a;
  }

  function deltaAngle( a, b ) {
    return fixAngle( b - a );
  }


</script>