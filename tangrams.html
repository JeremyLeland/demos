<link rel='stylesheet' href='./style.css'>

<style>
  body {
    display: flex;
  }
  svg {
    stroke: black;
    stroke-width: 0.04;
  }
  #main {
    position: absolute;
    background-color: gray;
    width: 100%;
    height: 100%;
  }
  #ui {
    margin: 0 auto;
  }
  .button {
    position: relative;
    border-radius: 25%;
    border: 2px solid black;
    background-color: lightslategray;
    width: 80px;
    height: 80px;
  }
</style>

<body>
  <svg id="main" viewBox="-6 -6 12 12">
    <g id="blocks"></g>
  </svg>
  <div id="ui"></div>
</body>

<script>
  const SVG_NS = 'http://www.w3.org/2000/svg';
  const TRI_HEIGHT = Math.sqrt( 3 ) / 2;
  const THIN_WIDTH = Math.cos( Math.PI / 12 );

  const BlockInfo = {
    hexagon: {
      points: [ 
        [ -1, 0 ], [ -1/2, -TRI_HEIGHT ], [ 1/2, -TRI_HEIGHT ], [ 1, 0 ], [ 1/2, TRI_HEIGHT ], [ -1/2, TRI_HEIGHT ]
      ],
      color: 'yellow',
    },
    // TODO: Extra point for long edge of trapezoid (so that all edges have length 1)?
    //       Then solution could be all the outer edges (of length 1)
    trapezoid: {
      points: [ 
        [ -1/2, -TRI_HEIGHT / 2 ], [ 1/2, -TRI_HEIGHT / 2 ], 
        [ 1, TRI_HEIGHT / 2 ], [ 0, TRI_HEIGHT / 2 ], [ -1, TRI_HEIGHT / 2 ]
      ],
      color: 'red',
    },
    diamond: {
      points: [ [ 0, -TRI_HEIGHT ], [ 1/2, 0 ], [ 0, TRI_HEIGHT ], [ -1/2, 0 ] ],
      color: 'blue',
    },
    triangle: {
      points: [ [ 0, -2 * TRI_HEIGHT / 3 ], [ 1/2, TRI_HEIGHT / 3 ], [ -1/2, TRI_HEIGHT / 3 ] ],
      color: 'green',
    },
    square: {
      points: [ [ -1/2, -1/2 ], [ 1/2, -1/2 ], [ 1/2, 1/2 ], [ -1/2, 1/2 ] ],
      color: 'orange',
    },
    thin: {
      points: [ [ 0, -THIN_WIDTH ], [ 1/4, 0 ], [ 0, THIN_WIDTH ], [ -1/4, 0 ] ],
      color: 'tan',
    },
  };

  function prepareCSS() {
    const styleSheet = document.styleSheets[ 1 ];

    for ( const type in BlockInfo ) {
      const info = BlockInfo[ type ];
      styleSheet.insertRule( `.${ type } {
        d: path( "M ${ info.points.join( ' L ' ) } Z" );
        fill: ${ info.color };
      }` );
    }
  }
  prepareCSS();

  function prepareUI() {
    const uiDiv = document.getElementById( 'ui' );

    for ( const type in BlockInfo ) {
      const svg = document.createElementNS( SVG_NS, 'svg' );
      svg.setAttribute( 'class', 'button' );
      svg.setAttribute( 'viewBox', '-1 -1 2 2' );

      const path = document.createElementNS( SVG_NS, 'path' );
      path.setAttribute( 'class', type );

      svg.addEventListener( 'click', () => addBlock( type ) );

      svg.appendChild( path );
      uiDiv.appendChild( svg );
    }
  }
  prepareUI();

  const SNAP_DIST = 0.2;

  class Edge {
    x1;
    y1;
    x2;
    y2;
    owner;

    constructor( info ) {
      Object.assign( this, info );
    }

    distanceFrom( other ) {
      // See https://stackoverflow.com/questions/2824478/shortest-distance-between-two-line-segments
      const rx = other.x1 - this.x1;
      const ry = other.y1 - this.y1;
      const ux = this.x2 - this.x1;
      const uy = this.y2 - this.y1;
      const vx = other.x2 - other.x1;
      const vy = other.y2 - other.y1;

      const ru = rx * ux + ry * uy;
      const rv = rx * vx + ry * vy;
      const uu = ux * ux + uy * uy;
      const uv = ux * vx + uy * vy;
      const vv = vx * vx + vy * vy;

      const det = uu * vv - uv * uv;
      let s, t;

      if ( det < 1e-6 * uu * vv ) {
        s = Math.max( 0, Math.min( ru / uu, 1 ) );
        t = 0;
      }
      else {
        s = Math.max( 0, Math.min( ( ru * vv - rv * uv ) / det, 1 ) );
        t = Math.max( 0, Math.min( ( ru * uv - rv * uu ) / det, 1 ) );
      }

      const S = Math.max( 0, Math.min( ( t * uv + ru ) / uu, 1 ) );
      const T = Math.max( 0, Math.min( ( s * uv - rv ) / vv, 1 ) );

      const Ax = this.x1 + S * ux;
      const Ay = this.y1 + S * uy;
      const Bx = other.x1 + T * vx;
      const By = other.y1 + T * vy;

      // lines will touch but face opposite directions
      const dAngle = deltaAngle( Math.atan2( uy, ux ), Math.atan2( -vy, -vx ) );

      return {
        A: this,
        Ax: Ax,
        Ay: Ay,
        B: other,
        Bx: Bx,
        By: By, 
        dist: Math.hypot( Bx - Ax, By - Ay ),   // TODO: directional distance with dot prod instead of hypot?
        dAngle: dAngle
      }
    }
  }
  
  class Block {
    type;
    x = 0;
    y = 0;
    angle = 0;

    edges = [];
    #svg;

    constructor( info ) {
      Object.assign( this, info );

      this.#svg = document.createElementNS( SVG_NS, 'path' );
      this.#svg.setAttribute( 'class', this.type );
      
      this.#svg.addEventListener( 'wheel', wheel );
      this.#svg.addEventListener( 'mousedown', inputStart );
      this.#svg.addEventListener( 'touchstart', inputStart );

      this.#svg.parent = this;
      blocksSVG.appendChild( this.#svg );
    }

    getEdges() {
      const cos = Math.cos( this.angle );
      const sin = Math.sin( this.angle );
      
      const edges = [];
      const points = BlockInfo[ this.type ].points;
      for ( let i = 0; i < points.length; i ++ ) {
        const current = points[ i ], next = points[ ( i + 1 ) % points.length ];

        edges.push( new Edge( {
          x1: this.x + cos * current[ 0 ] - sin * current[ 1 ],
          y1: this.y + sin * current[ 0 ] + cos * current[ 1 ],
          x2: this.x + cos * next[ 0 ] - sin * next[ 1 ],
          y2: this.y + sin * next[ 0 ] + cos * next[ 1 ],
        } ) );
      }

      return edges;
    }

    updateSVG() {
      this.#svg.style.transform = `translate( ${ this.x }px,${ this.y }px ) rotate( ${ this.angle }rad )`;
    }
  }


  const blocks = [];

  const blocksSVG = document.getElementById( 'blocks' );

  const level = [
    // { type: 'hexagon', x: -4, y: 0, angle: 0 },
    // { type: 'trapezoid', x: -2, y: 0, angle: 0 },
    // { type: 'diamond', x: 0, y: 0, angle: 0 },
    // { type: 'triangle', x: 2, y: 0, angle: 0 },
    // { type: 'square', x: 4, y: 0, angle: 0 },
    // { type: 'thin', x: 5, y: 0, angle: 0 },
  ]

  level.forEach( block => blocks.push( new Block( block ) ) );


  blocks.forEach( block => block.updateSVG() );

  
  // // For later, if we ever try to save level state in URL
  // const levelAscii = JSON.stringify( level );
  // const levelBase64 = btoa( levelAscii );

  // console.log( levelBase64 );

  // 
  // Input
  //
  document.addEventListener( 'mousemove', inputMove );
  document.addEventListener( 'touchmove', inputMove );
  document.addEventListener( 'mouseup', inputStop );
  document.addEventListener( 'touchend', inputStop );

  let activeBlock, lastX, lastY;
  function wheel( e ) {
    const block = activeBlock ?? e.currentTarget.parent;

    block.angle -= ( e.wheelDelta / 120 ) * ( Math.PI / 12 );
    block.updateSVG();
  }

  function inputStart( e ) {
    activeBlock = e.currentTarget.parent;

    const pos = e.touches?.[ 0 ] ?? e;
    lastX = pos.pageX;
    lastY = pos.pageY;
  }

  function inputMove( e ) {
    if ( activeBlock ) {
      const pos = e.touches?.[ 0 ] ?? e;
      const ratio = 12 / Math.min( window.innerWidth, window.innerHeight );
      const dx = ( pos.pageX - lastX ) * ratio;
      const dy = ( pos.pageY - lastY ) * ratio;
      lastX = pos.pageX;
      lastY = pos.pageY;

      activeBlock.x += dx;
      activeBlock.y += dy;

      const activeEdges = activeBlock.getEdges();
      const otherEdges = blocks.filter( b => b != activeBlock ).flatMap( b => b.getEdges() );
      

      const edgeDists = activeEdges.flatMap( a => otherEdges.map( e => a.distanceFrom( e ) ) );

      // TODO: Take dx/dy into account when snapping -- are we moving toward snap or away from it?
      //       We need to be able to move pieces again after they've snapped the first time

      // Find closest edge with smallest difference in angle
      edgeDists.sort( ( a, b ) => a.dist - b.dist );

      // NOTE: Need to be generous with distances here since since the wrong lines sometimes appear closer
      // TODO: Another possible way to do this would be some sort of "average distance" of x1,y1 and x2,y2
      //       If both of those points are closer to segment, it would have lower "average distance" than an
      //       edge where only one point touches
      // TODO: Could also do the movement calculation below as part of distance detection, 
      //       and use whichever has smallest move instead of the actual distance
      const nearest = edgeDists.filter( e => e.dist - edgeDists[ 0 ].dist < 0.1 );
      nearest.sort( ( a, b ) => Math.abs( a.dAngle ) - Math.abs( b.dAngle ) );

      const bestAlign = nearest[ 0 ];
      if ( bestAlign && bestAlign.dist < SNAP_DIST ) {
        // Since edges are running opposite directions, we will compare x1,y1 to x2,y2 and vice versa
        const px = activeBlock.x - bestAlign.A.x1;
        const py = activeBlock.y - bestAlign.A.y1;

        const cos = Math.cos( bestAlign.dAngle );
        const sin = Math.sin( bestAlign.dAngle );
        const newX = px * cos - py * sin;
        const newY = px * sin + py * cos; 

        activeBlock.x = bestAlign.B.x2 + newX;
        activeBlock.y = bestAlign.B.y2 + newY;

        activeBlock.angle += bestAlign.dAngle;
      }

      activeBlock.updateSVG();
    }
  }

  function inputStop( e ) {
    activeBlock = null;
  }

  function addBlock( type ) {
    // TODO: Spawn where user clicks on button, so they can drag it in?
    const block = new Block( { type: type } );
    
    blocks.push( block );
    //activeBlock = block;
  }


  function fixAngle( a ) {
    return a > Math.PI ? a - Math.PI * 2 : a < -Math.PI ? a + Math.PI * 2 : a;
  }

  function deltaAngle( a, b ) {
    return fixAngle( b - a );
  }

</script>