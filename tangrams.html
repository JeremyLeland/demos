<link rel='stylesheet' href='./style.css'>

<style>
  svg {
    background-color: gray;
    width: 100%;
    height: 100%;
    stroke: black;
    stroke-width: 0.04;
  }
</style>

<body>
  <svg id='svg' viewBox="-6 -6 12 12"></svg>
</body>

<script>
  const TRI_HEIGHT = Math.sqrt( 3 ) / 2;
  const THIN_WIDTH = Math.cos( Math.PI / 12 );

  const BlockInfo = {
    hexagon: {
      points: [ 
        [ -1, 0 ], [ -1/2, -TRI_HEIGHT ], [ 1/2, -TRI_HEIGHT ], [ 1, 0 ], [ 1/2, TRI_HEIGHT ], [ -1/2, TRI_HEIGHT ]
      ],
      color: 'yellow',
    },
    trapezoid: {
      points: [ [ -1, TRI_HEIGHT / 2 ], [ -1/2, -TRI_HEIGHT / 2 ], [ 1/2, -TRI_HEIGHT / 2 ], [ 1, TRI_HEIGHT / 2 ] ],
      color: 'red',
    },
    diamond: {
      points: [ [ 0, -TRI_HEIGHT ], [ 1/2, 0 ], [ 0, TRI_HEIGHT ], [ -1/2, 0 ] ],
      color: 'blue',
    },
    triangle: {
      points: [ [ 0, -2 * TRI_HEIGHT / 3 ], [ 1/2, TRI_HEIGHT / 3 ], [ -1/2, TRI_HEIGHT / 3 ] ],
      color: 'green',
    },
    square: {
      points: [ [ -1/2, -1/2 ], [ 1/2, -1/2 ], [ 1/2, 1/2 ], [ -1/2, 1/2 ] ],
      color: 'orange',
    },
    thin: {
      points: [ [ 0, -THIN_WIDTH ], [ 1/4, 0 ], [ 0, THIN_WIDTH ], [ -1/4, 0 ] ],
      color: 'tan',
    },
  };

  function prepareCSS() {
    const styleSheet = document.styleSheets[ 1 ];

    for ( const type in BlockInfo ) {
      const info = BlockInfo[ type ];
      styleSheet.insertRule( `.${ type } {
        d: path( "M ${ info.points.join( ' L ' ) } Z" );
        fill: ${ info.color };
      }` );
    }
  }
  prepareCSS();  

  class Edge {
    x1;
    y1;
    x2;
    y2;
    link;
    owner;

    constructor( info ) {
      Object.assign( this, info );
    }

    getTransformed( angle = this.owner.angle ) {
      const cosX = Math.cos( angle );
      const sinX = Math.sin( angle );
      const cosY = Math.cos( angle + Math.PI / 2 );
      const sinY = Math.sin( angle + Math.PI / 2 );

      return {
        x1: this.owner.x + cosX * this.x1 + cosY * this.y1,
        y1: this.owner.y + sinX * this.x1 + sinY * this.y1,
        x2: this.owner.x + cosX * this.x2 + cosY * this.y2,
        y2: this.owner.y + sinX * this.x2 + sinY * this.y2,
      };
    }

    getTransformToAlignWith( other ) {
      const seg1 = this.getTransformed();
      const seg2 = other.getTransformed();

      // Since edges are running opposite directions, we will compare x1,y1 to x2,y2 and vice versa
      const dAngle = deltaAngle(
        Math.atan2( seg1.y2 - seg1.y1, seg1.x2 - seg1.x1 ),
        Math.atan2( seg2.y1 - seg2.y2, seg2.x1 - seg2.x2 ),
      );

      const seg1rotated = this.getTransformed( this.owner.angle + dAngle );
      
      return {
        dx: seg2.x2 - seg1rotated.x1,
        dy: seg2.y2 - seg1rotated.y1, 
        dAngle: dAngle
      };
    }
  }
  
  class Block {
    type;
    x = 0;
    y = 0;
    angle = 0;

    edges = [];
    #svg;

    constructor( info ) {
      Object.assign( this, info );

      const blockInfo = BlockInfo[ this.type ];

      const size = 100;
      const points = blockInfo.points;
      for ( let i = 0; i < points.length; i ++ ) {
        const current = points[ i ], next = points[ ( i + 1 ) % points.length ];

        this.edges.push( new Edge( { 
          x1: current[ 0 ], 
          y1: current[ 1 ],
          x2: next[ 0 ],
          y2: next[ 1 ],
          owner: this, 
        } ) );
      }

      this.#svg = document.createElementNS( 'http://www.w3.org/2000/svg', 'path' );
      this.#svg.setAttribute( 'class', this.type );
      
      this.#svg.addEventListener( 'wheel', wheel );
      this.#svg.addEventListener( 'mousedown', inputStart );
      this.#svg.addEventListener( 'touchstart', inputStart );

      this.#svg.parent = this;
      svg.appendChild( this.#svg );
    }

    updateSVG() {
      this.#svg.style.transform = `translate( ${ this.x }px,${ this.y }px ) rotate( ${ this.angle }rad )`;
    }
  }


  const blocks = [];

  const svg = document.getElementById( 'svg' );

  const level = [
    { type: 'hexagon', x: -4, y: 0, angle: 0 },
    { type: 'trapezoid', x: -2, y: 0, angle: 0 },
    { type: 'diamond', x: 0, y: 0, angle: 0 },
    { type: 'triangle', x: 2, y: 0, angle: 0 },
    { type: 'square', x: 4, y: 0, angle: 0 },
    { type: 'thin', x: 5, y: 0, angle: 0 },
  ]

  level.forEach( block => blocks.push( new Block( block ) ) );

  function align( target, targetEdge, destination, destinationEdge ) {
    const transform = target.edges[ targetEdge ].getTransformToAlignWith( destination.edges[ destinationEdge ] );
    target.x += transform.dx;
    target.y += transform.dy;
    target.angle += transform.dAngle;
  }

  align( blocks[ 0 ], 0, blocks[ 1 ], 1 );
  align( blocks[ 2 ], 0, blocks[ 1 ], 2 );
  align( blocks[ 3 ], 0, blocks[ 2 ], 3 );
  align( blocks[ 4 ], 0, blocks[ 0 ], 3 );
  align( blocks[ 5 ], 1, blocks[ 4 ], 3 );


  blocks.forEach( block => block.updateSVG() );

  
  // For later, if we ever try to save level state in URL
  const levelAscii = JSON.stringify( level );
  const levelBase64 = btoa( levelAscii );

  console.log( levelBase64 );

  // 
  // Input
  //
  document.addEventListener( 'mousemove', inputMove );
  document.addEventListener( 'touchmove', inputMove );
  document.addEventListener( 'mouseup', inputStop );
  document.addEventListener( 'touchend', inputStop );

  let activeBlock, lastX, lastY;
  function wheel( e ) {
    const block = activeBlock ?? e.currentTarget.parent;

    block.angle -= ( e.wheelDelta / 120 ) * ( Math.PI / 12 );
    block.updateSVG();

  }

  function inputStart( e ) {
    activeBlock = e.currentTarget.parent;

    const pos = e.touches?.[ 0 ] ?? e;
    lastX = pos.pageX;
    lastY = pos.pageY;
  }

  function inputMove( e ) {
    if ( activeBlock ) {
      const pos = e.touches?.[ 0 ] ?? e;
      const ratio = 10 / Math.min( window.innerWidth, window.innerHeight );
      const dx = ( pos.pageX - lastX ) * ratio;
      const dy = ( pos.pageY - lastY ) * ratio;
      lastX = pos.pageX;
      lastY = pos.pageY;

      activeBlock.x += dx;
      activeBlock.y += dy;

      activeBlock.updateSVG();
    }
  }

  function inputStop( e ) {
    activeBlock = null;
  }


  function fixAngle( a ) {
    return a > Math.PI ? a - Math.PI * 2 : a < -Math.PI ? a + Math.PI * 2 : a;
  }

  function deltaAngle( a, b ) {
    return fixAngle( b - a );
  }


</script>